<html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="这篇文章介绍了逆向工程Nintendo DS（NDS）游戏的基础知识，涵盖ARM汇编语言的核心概念，包括寄存器、内存、指令、函数调用以及调用栈的使用等。文章详细讲解了如何使用ldmia和stmia指令操作结构体和数组数据，展示了实现switch语句的跳转表方式等实际应用。最后，文章总结了学习ARM汇编的技巧，并引入了逆向工程工具Ghidra以进行更深入的NDS游戏代码分析。"><title>如何逆向NDS游戏（中）：ARM32汇编入门 - Cerallin的笔记本 - 瞎折腾～～</title><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="/notes/css/style.css"><link rel="stylesheet" href="/notes/css/helpers.css"><script src="/notes/js/clipboard/clipboard.min.js"></script><script src="/notes/js/bootstrap.js"></script><script>Theme.counter={register:function(){request("//visitor-counter.cerallin.top/count.php/?page="+encodeURI(window.location.href),{method:"GET"}).then(e=>{for(var t in e){var n=document.getElementById(t);n&&(n.innerText=e[t])}}).catch(e=>{console.error("Fetching visit count failed.",e)})}}</script><style>body hl:after {
    content: ' ';
    display: inline;
    font-family: inherit;
    font-size: 0.45em;
}

html code hl,
html pre hl,
html kbd hl,
html samp hl,
html ruby hl,
html .tag-list-item hl {
    display: none;
}

html ol > hl,
html ul > hl {
    display: none;
}</style><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/notes/atom.xml" title="Cerallin的笔记本" type="application/atom+xml"></head><body><div class="loading-wrapper" data-loading="data-loading"><div class="loading"><span></span><span></span><span></span></div></div><div class="page" data-filter="data-filter"><div class="head" data-show="data-show"><header class="head-header"><div class="head-author"><a class="head-author-link" href="/notes/">Cerallin<hl></hl>的笔记本</a></div><div class="head-right"><button class="bar-wrap" id="bar-wrap-toggle" title="菜单按钮"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button><div class="head-item"><a class="search-button head-item-link"><span>搜索</span> <i class="icon icon-search"></i></a></div><div class="head-item"><a class="head-item-link" href="/notes/about">关于</a></div></div></header><div class="menubar-head" id="menubar"><ul class="menubar-ul"><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%B7%A5%E7%A8%8B/">计算机与通信工程</a></li><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E6%9D%90%E6%96%99%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/">材料科学与工程</a></li><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/">瞎折腾</a></li><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E6%B5%85%E6%80%9D/">浅思</a></li><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><i class="icon icon-archive"></i> <a class="menubar-link" href="/notes/archives">归档</a></li><li class="menubar-item"><i class="icon icon-tags"></i> <a class="menubar-link" href="/notes/tags">标签</a></li><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><a class="menubar-link" href="/notes/about"><span>关于</span></a></li></ul><div class="menu-search-box search-button"><div>搜索</div><i class="icon icon-search"></i></div></div></div><div class="main" data-page="post"><article class="post" id="post"><header class="post-head"><h1 class="post-title"><a class="title" href="/notes/2024/10/02/%E5%A6%82%E4%BD%95%E9%80%86%E5%90%91NDS%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%AD%EF%BC%89/">如何逆向<hl></hl>NDS<hl></hl>游戏（中）：ARM32<hl></hl>汇编入门<hl></hl></a></h1></header><div class="post-meta"><div class="post-date"><time class="post-time" itemprop="datePublished" title="2024-10-02 14:48:36" datetime="2024-10-02T06:48:36.000Z">2024-10-02</time></div>|<div class="post-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/ARM/" rel="tag">ARM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/NDS/" rel="tag">NDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/%E6%B1%87%E7%BC%96/" rel="tag"><hl></hl>汇编</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" rel="tag">逆向工程</a></li></ul></div><div class="post-visit"><span id="page_pv">?</span><hl></hl>访问</div></div><div class="post-info"><div class="post-word-count">本文共<hl></hl>8,167<hl></hl>字。</div><div class="post-cc">版权声明：署名 | <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div><div class="article-entry" itemprop="articleBody"><blockquote><p>本文翻译自《<a target="_blank" rel="noopener" href="https://www.starcubelabs.com/reverse-engineering-ds/">Reverse Engineering a DS Game</a>》。</p></blockquote><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Assembly_language">汇编语言</a>（简称为汇编或<hl></hl>ASM）是一种低级编程语言，它与计算机读取和执行的二进制指令（机器代码）非常接近。与<hl></hl>C<hl></hl>这样更高级的语言相比，汇编的抽象较少。例如，函数调用在<hl></hl>C<hl></hl>中是一行语句，但这一操作在汇编中可能对应多行代码。我们稍后会展示具体的例子。</p><span id="more"></span><h2 id="汇编入门">汇编入门</h2><blockquote><p>本教程旨在提供汇编语言的简要介绍，帮助你入门。为了简洁起见，我会跳过一些细节。如果你对更全面的<hl></hl>NDS<hl></hl>汇编参考感兴趣，可以查看<hl></hl>Tonc<hl></hl>的<hl></hl><a target="_blank" rel="noopener" href="https://www.coranac.com/tonc/text/asm.htm#sec-arm">ARM<hl></hl>汇编快速指南</a>。</p></blockquote><p>不同的<hl></hl>CPU<hl></hl>可能使用不同的汇编语言，这取决于<hl></hl>CPU<hl></hl>支持的操作（即<hl></hl>CPU<hl></hl>的<strong>指令集</strong>）。虽然所有<hl></hl>CPU<hl></hl>都支持计算机正常运行所需的最小指令集，但额外的指令则像是快捷方式，使得程序能够编译为更少的汇编代码行数，从而提高程序的执行速度。代价是需要更复杂的<hl></hl>CPU<hl></hl>硬件来支持这些额外的指令，同时这些指令可能会占用更多的存储空间。本教程将使用<hl></hl><strong>ARM</strong><hl></hl>指令集，因为这是《空之探险队》代码使用的主要指令集。在本教程中，“汇编”<hl></hl>为<hl></hl>“ARM<hl></hl>指令集汇编语言”<hl></hl>的简写；在特定游戏的语境中，这是常见的简写方式。</p><blockquote><p>除了<hl></hl>ARM，NDS<hl></hl>的<hl></hl>CPU<hl></hl>还支持另一种指令集：<strong>THUMB</strong>。与<hl></hl>ARM<hl></hl>相比，THUMB<hl></hl>的指令更简单，但需要更多的指令来实现与<hl></hl>ARM<hl></hl>相同的功能。许多<hl></hl>DS<hl></hl>游戏（如《空之探险队》）主要使用<hl></hl>ARM<hl></hl>代码，虽然一些<hl></hl>DS<hl></hl>游戏大量使用<hl></hl>THUMB<hl></hl>指令集。尽管本教程不涉及<hl></hl>THUMB<hl></hl>指令集，但一旦你掌握了<hl></hl>ARM<hl></hl>指令集，学习<hl></hl>THUMB<hl></hl>会相对容易。</p></blockquote><p>以下是一个简单的汇编赋值指令。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="number">#0x0</span></span><br></pre></td></tr></tbody></table></figure><p>这条语句将数字<hl></hl>0（#0x0）赋给<hl></hl><code>r0</code>，<code>r0</code><hl></hl>是<hl></hl>CPU<hl></hl>的一个寄存器（Register）。寄存器是啥？让我们先来了解一下。</p><h3 id="寄存器">寄存器</h3><p><strong>寄存器</strong>是<hl></hl>CPU<hl></hl>硬件中用于存储值的位置。当<hl></hl>CPU<hl></hl>需要保存数据以备后用时，寄存器是读写数据最快的地方。每一条汇编操作都会以某种方式与寄存器交互。</p><p>CPU<hl></hl>通常只有少量可用的寄存器。在<hl></hl>ARM CPU<hl></hl>中，寄存器的命名格式为<hl></hl><code>rX</code>，其中<hl></hl>“X”<hl></hl>是从<hl></hl>0<hl></hl>开始的寄存器编号。 NDS<hl></hl>的<hl></hl>CPU<hl></hl>有<hl></hl>16<hl></hl>个寄存器，从<hl></hl><code>r0</code><hl></hl>到<hl></hl><code>r15</code>，每个寄存器可以存储多达<hl></hl>32<hl></hl>位（4<hl></hl>字节）的数据，总计可以存储<hl></hl>512<hl></hl>位（64<hl></hl>字节）数据。</p><p><code>r15</code><hl></hl>是一个特殊的寄存器，被<strong>程序计数器</strong>（program counter），简称<hl></hl><strong>PC</strong>。该寄存器保存着下一条将要加载的指令的地址，指令加载后该地址会自动增<hl></hl>4（因为每条指令占<hl></hl>4<hl></hl>字节）。于是汇编指令按行顺序执行。如果设置<hl></hl>PC<hl></hl>的值，CPU<hl></hl>就可以跳转到新地址然后开始执行那里的代码；分支、循环和函数调用等就是这样实现的。 CPU<hl></hl>在执行指令前会略微提前加载指令，因此<hl></hl>PC<hl></hl>可能会比当前正在执行的指令提前几条指令。</p><p>其他一些寄存器也有特殊名称和用途，我们稍后会讨论这些。</p><h3 id="内存">内存</h3><p>寄存器容量有限，因此如果程序需要存储的数据超过寄存器的容量，数据会存储到<strong>主内存</strong>，也被称为<hl></hl><strong>RAM</strong>（random-access memory，随机存取存储器）或简称为<strong>内存</strong>。使用内存比使用寄存器存储和访问数据更慢，但内存容量更大。 NDS<hl></hl>有<hl></hl>4MB<hl></hl>的<hl></hl>RAM<hl></hl>供常规代码操作使用，此外还有用于特殊操作（如<hl></hl>I/O）的保留<hl></hl>RAM。</p><h3 id="rom">ROM</h3><p>用于加载游戏的<hl></hl><strong>ROM</strong>（只读存储器）文件实际上是一个字节数组。这些字节编码了诸如<hl></hl>spite<hl></hl>图像和音频的资源、游戏逻辑使用的数据值（例如某种治疗物品将为玩家恢复多少生命值）以及用于运行游戏的代码。</p><p>在讨论<hl></hl>ROM<hl></hl>中的数据时，通常根据数据从<hl></hl>ROM<hl></hl>开头以<hl></hl>0<hl></hl>起始的<strong>地址</strong>（<strong>偏移量</strong>）来引用一段数据。例如，ROM<hl></hl>文件中的第一个字节位于地址<hl></hl>0x0，ROM<hl></hl>文件中的第<hl></hl>5<hl></hl>个字节位于地址<hl></hl>0x4。地址几乎总是以十六进制表示；“0x”<hl></hl>表示一个值是以十六进制格式表示的。在逆向工程的语境下，十六进制也常用于其他值。</p><p>直接访问<hl></hl>ROM<hl></hl>相对较慢，因此<hl></hl>NDS<hl></hl>会在执行代码和读取数据之前将<hl></hl>ROM<hl></hl>加载到内存中。尽管实际上<hl></hl>ROM<hl></hl>数据是内存<hl></hl>/RAM<hl></hl>的一部分，但内存中存储<hl></hl>ROM<hl></hl>数据的区域通常仍被称为<hl></hl>“ROM”。内存没有足够的空间一次性加载整个<hl></hl>ROM，因此一次只能加载部分<hl></hl>ROM。</p><h3 id="overlay">overlay</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Overlay_(programming)"><strong>overlay</strong></a><hl></hl>是一种设计模式，允许计算机运行超过其内存容量的程序。程序的代码被分为若干块，被称为<hl></hl><strong>overlay</strong>，一次只加载部分<hl></hl>overlay<hl></hl>到内存中。当程序状态变化并需要不同的<hl></hl>overlay<hl></hl>时，计算机会将内存中不再需要的<hl></hl>overlay<hl></hl>替换为程序当前需要的<hl></hl>overlay。</p><p>NDS<hl></hl>将每个<hl></hl>overlay<hl></hl>加载到内存的特定区域。一些<hl></hl>overlay<hl></hl>在内存中可能会重叠，但只有当两个<hl></hl>overlay<hl></hl>不会同时加载时，它们才可以重叠。</p><p>《空之探险队》有<hl></hl>36<hl></hl>个<hl></hl>overlay。处理迷宫内游戏玩法的代码存储在<hl></hl>overlay 29<hl></hl>和<hl></hl>overlay 31<hl></hl>中，而处理过场动画和外部世界移动的代码存储在<hl></hl>overlay 11<hl></hl>中。迷宫和外部世界的玩法都需要<hl></hl>overlay 10，因此在这两种模式下都会加载该<hl></hl>overlay。overlay 29<hl></hl>加载到地址<hl></hl>0x22DC240，overlay 10<hl></hl>加载到地址<hl></hl>0x22BCA80，overlay 31<hl></hl>加载到地址<hl></hl>0x2382820。</p><p>在游戏中访问<hl></hl>overlay<hl></hl>中的值的时候，使用其在<hl></hl>overlay<hl></hl>文件中的地址加上该<hl></hl>overlay<hl></hl>文件的地址。例如，<code>overlay_0029.bin</code><hl></hl>文件中地址<hl></hl>0x4<hl></hl>的数据在游戏中使用地址<hl></hl>0x22DC244（0x4 + 0x22DC240）进行访问。</p><p>例外情况是<hl></hl><code>arm9.bin</code><hl></hl>和<hl></hl><code>arm7.bin</code>。它们包含游戏的核心系统，例如加载<hl></hl>overlay<hl></hl>所需的代码，因此它们从不会被卸载。 <code>arm9.bin</code><hl></hl>加载到地址<hl></hl>0x2000000，而<hl></hl><code>arm7.bin</code><hl></hl>由<hl></hl>DS<hl></hl>的次级<hl></hl>ARM7TDMI CPU<hl></hl>处理。除非你研究它负责的特殊进程（如音频），否则你不需要担心<hl></hl><code>arm7.bin</code>。</p><blockquote><p>在之前的<hl></hl>Ghidra<hl></hl>设置过程中，你将<hl></hl><code>arm9.bin</code><hl></hl>的基址设置为<hl></hl>0x2000000，并将<hl></hl>overlay<hl></hl>文件设置为它们各自的地址。这与<hl></hl>DS<hl></hl>在内存中加载<hl></hl>ROM<hl></hl>文件的位置相匹配，将这些地址提供给<hl></hl>Ghidra<hl></hl>有助于它更好地分析代码。</p></blockquote><p>每个可以加载的<hl></hl>overlay<hl></hl>子集都需要你将<hl></hl><code>arm9.bin</code><hl></hl>重新导入为项目中的新文件。之前的<hl></hl>Ghidra<hl></hl>设置可以帮助你逆向工程《空之探险队》的迷宫玩法，加载了<hl></hl><code>arm9.bin</code><hl></hl>并添加了<hl></hl>overlay 10、29<hl></hl>和<hl></hl>31。如果你想分析外部世界的玩法，需要重新加载<hl></hl><code>arm9.bin</code><hl></hl>并添加<hl></hl>overlay 10<hl></hl>和<hl></hl>11。</p><h4 id="查找overlay">查找<hl></hl>overlay</h4><p>每个<hl></hl>overlay<hl></hl>在内存中的起始地址定义在<hl></hl>ROM<hl></hl>中的一个文件中，被称为<hl></hl><strong>overlay<hl></hl>表</strong>（<strong>OVT</strong>）。OVT<hl></hl>是从<hl></hl>ROM<hl></hl>解压出来的文件<hl></hl><code>y9.bin</code>。你可以使用十六进制编辑器打开这个文件，如<hl></hl><a target="_blank" rel="noopener" href="https://mh-nexus.de/en/hxd/">HxD</a>（Windows）或<hl></hl><a target="_blank" rel="noopener" href="https://hexfiend.com/">Hex Fiend</a>（macOS）。</p><p>在<hl></hl><code>y9.bin</code><hl></hl>中，每个<hl></hl>overlay<hl></hl>按顺序列出，首先是<hl></hl>overlay<hl></hl>编号，然后是地址，接着是其他一些信息，如<hl></hl>overlay<hl></hl>的大小，最后是<hl></hl>4<hl></hl>个字节（即一个字）的<hl></hl>0<hl></hl>作为<hl></hl>overlay<hl></hl>之间的分隔符。要找到<hl></hl>overlay<hl></hl>的起始地址，首先查找紧跟在<hl></hl>00000000<hl></hl>之后的<hl></hl>overlay<hl></hl>编号，然后查看下一个字，得到<hl></hl>overlay<hl></hl>的地址。overlay<hl></hl>的地址是小端序的，因此需要反向读取字节（例如，小端序的<hl></hl>80 CA 2B 02<hl></hl>等于<hl></hl>0x022BCA80）。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/overlay-table.png" alt="《空之探险队》的OVT，其中overlay 10（0xA）部分被高亮显示。overlay 10的地址为80 CA 2B 02（0x022BCA80）。"><figcaption aria-hidden="true">《空之探险队》的<hl></hl>OVT，其中<hl></hl>overlay 10（0xA）部分被高亮显示。overlay 10<hl></hl>的地址为<hl></hl>80 CA 2B 02（0x022BCA80）。</figcaption></figure><p>一旦知道了<hl></hl>overlay<hl></hl>的地址，你就可以运行游戏，查看内存中该<hl></hl>overlay<hl></hl>的地址，并与<hl></hl>overlay<hl></hl>文件的起始部分进行比较，看看字节是否匹配。如果匹配，则该<hl></hl>overlay<hl></hl>当前已加载到内存中。</p><p>大多数游戏都有一个内存区域列出当前加载的<hl></hl>overlay。例如，《空之探险队》的<hl></hl>overlay<hl></hl>加载列表位于地址<hl></hl>0x20AF230。然而，这个列表的位置在不同游戏之间并不统一。找到该列表并不容易，超出了本教程的范围。但如果一个游戏的逆向工程社区已经找到了<hl></hl>OVT，那么查找<hl></hl>overlay<hl></hl>的任务就大大简化了。</p><h3 id="指令">指令</h3><p>指令是用于操作寄存器或内存中的数据的。CPU<hl></hl>根据程序计数器的值按顺序执行指令。</p><p>每条指令都是<hl></hl>4<hl></hl>个字节的数据。当指令被编码为字节时，被称为<strong>二进制码</strong>或<strong>机器码</strong>。逆向工程工具可以读取这些字节，并将它们转换为更易读的汇编代码。</p><h4 id="赋值">赋值</h4><p>下面是之前展示的赋值指令：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="number">#0x0</span></span><br></pre></td></tr></tbody></table></figure><p>该指令有三个部分：</p><p><img loading="lazy" src="/notes/images/nds-reverse-engineering/movs-ds.png"></p><ul><li><strong>助记符</strong>：要执行的操作的简写名称。<code>mov</code><hl></hl>指令将一个值赋给寄存器。</li><li><strong>目标</strong>：要设置值的寄存器。在此指令中，将设置<hl></hl><code>r0</code><hl></hl>的值。</li><li><strong>源</strong>：要存储在目标寄存器的值的来源。在这种情况下，值是常量<hl></hl>0；在汇编术语中，被称为<strong>立即数</strong>（immediate number，意为该数不表示任何内存地址而直接表示一个值，所以为什么不翻译成直接数呢——译注）。</li></ul><p>将这三部分结合起来，这条指令将<hl></hl><code>r0</code><hl></hl>的值设置为<hl></hl>0，丢弃了<hl></hl><code>r0</code><hl></hl>中先前的值。</p><p>来源也可以是另一个寄存器。以下指令将<hl></hl><code>r1</code><hl></hl>的值复制到<hl></hl><code>r0</code><hl></hl>中。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="built_in">r1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="算术">算术</h4><p>我们来看另一种类型的指令。下面的指令是一条加法操作。</p><p>这条指令将<hl></hl>1<hl></hl>加到<hl></hl><code>r1</code><hl></hl>中的值，并将其存储到<hl></hl><code>r0</code><hl></hl>中。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">r0</span>, <span class="built_in">r1</span>, <span class="number">#0x1</span></span><br></pre></td></tr></tbody></table></figure><p><code>r0</code><hl></hl>是与之前一样的目标寄存器。由于加法需要两个操作数，这里有两个来源，<code>r1</code><hl></hl>和<code>#0x1</code>。可以将一个寄存器与一个立即数相加，或者两个寄存器相加。如果指令使用立即数，立即数必须始终位于最后；这个限制与指令在<hl></hl>CPU<hl></hl>硬件中的实现方式有关。</p><p>如果你想将立即数加到寄存器值上，并将新值存回同一个寄存器，你可以使用以下简写。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">r0</span>, <span class="number">#0x1</span></span><br></pre></td></tr></tbody></table></figure><p>这条指令把<hl></hl>1<hl></hl>和<hl></hl><code>r0</code><hl></hl>相加，结果存储在<hl></hl><code>r0</code><hl></hl>中。或者你可以说这是自增<hl></hl><code>r0</code><hl></hl>中的值。</p><p>其他可用的数学运算符包括减法、乘法、取负、按位与<hl></hl>/<hl></hl>或<hl></hl>/<hl></hl>异或<hl></hl>/<hl></hl>非，以及逻辑<hl></hl>/<hl></hl>算术（无符号<hl></hl>/<hl></hl>有符号）左<hl></hl>/<hl></hl>右移位。这些操作中的一些比加法更为严格，例如不支持立即数，但它们都遵循类似的结构。有关支持的指令的完整列表，请参考<hl></hl><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference?lang=en">ARM<hl></hl>的开发者文档</a>。</p><blockquote><p>你可能注意到没有除法指令。与上面列出的操作相比，任意数的除法要复杂得多，因此它实现为一个函数，而不是一条指令。这意味着除法比其他数学操作要慢得多。注意，右移操作符可以通过<hl></hl>2<hl></hl>的幂将数字除以某些值，从而在一条指令中实现某些除法。</p></blockquote><p>如果两个来源都是寄存器，ARM<hl></hl>还支持对第二个来源寄存器进行移位，并在指令中使用移位后的值。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">r0</span>, <span class="built_in">r1</span>, <span class="built_in">r2</span>, <span class="keyword">lsl</span> <span class="number">#0x2</span></span><br></pre></td></tr></tbody></table></figure><p>上面的指令先将<hl></hl><code>r2</code><hl></hl>左移<hl></hl>2<hl></hl>位（即乘以<hl></hl>4），然后进行加法操作，等效于<hl></hl><code>r0 = r1 + r2 * 4</code>。</p><h4 id="加载存储内存">加载<hl></hl>/<hl></hl>存储内存</h4><p>寄存器只能存储少量的值，因此程序的大部分数据存储于内存。前文提到，内存（也可称之为主内存或<hl></hl>RAM）是存储大部分数据的地方，因为寄存器的存储容量有限。</p><p>以下是一条把值存储到内存的指令。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">str</span> <span class="built_in">r0</span>, [<span class="built_in">r1</span>, <span class="number">#0x4</span>]</span><br></pre></td></tr></tbody></table></figure><ul><li>助记符<hl></hl>“str”<hl></hl>表示<hl></hl>“存储寄存器（store register）”。</li><li><code>r0</code><hl></hl>是源寄存器，包含要存储到主内存中的值。</li><li>中括号里的<hl></hl><code>r1</code>（寄存器）和<code>#0x4</code>（可以是立即数或寄存器）相加，结果作为存储值的内存地址。立即数可以为<hl></hl>0，表示将值直接存储到<hl></hl><code>r1</code><hl></hl>中的地址。</li></ul><p>例如，如果<hl></hl><code>r0</code><hl></hl>的值是<hl></hl>3，<code>r1</code><hl></hl>的值是<hl></hl>0x2000000，那么内存地址<hl></hl>0x2000004（0x2000000 + 4）将会写入值<hl></hl>3。由于寄存器的值长度为<hl></hl>4<hl></hl>个字节，完整的值将存储在内存地址<hl></hl>0x2000004<hl></hl>到<hl></hl>0x2000007<hl></hl>之间（包括在内）。</p><p>替代指令<hl></hl><code>strh</code><hl></hl>和<hl></hl><code>strb</code><hl></hl>分别用于存储源寄存器的低<hl></hl>2<hl></hl>字节（半字，half word）和<hl></hl>1<hl></hl>字节（byte）。</p><p>从内存加载数据的格式与存储类似，只不过数据流的方向相反。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr</span> <span class="built_in">r0</span>, [<span class="built_in">r1</span>, <span class="number">#0x4</span>]</span><br></pre></td></tr></tbody></table></figure><p>“ldr”<hl></hl>表示<hl></hl>“加载寄存器（load register）”。该指令从<hl></hl><code>r1</code><hl></hl>加上立即偏移量<hl></hl>4<hl></hl>的地址加载数据，并将加载的值存储到<hl></hl><code>r0</code><hl></hl>中。与<hl></hl><code>str</code><hl></hl>一样，也有用于加载半字（<code>ldrh</code>）和单字节（<code>ldrb</code>）的指令。</p><p>除了从寄存器地址加载数据，<code>ldr</code><hl></hl>还可以加载汇编代码中的硬编码值。这些值在<hl></hl>Ghidra<hl></hl>中标记为<hl></hl><code>DAT_&lt;address&gt;</code>，其中<hl></hl><code>&lt;address&gt;</code><hl></hl>是<hl></hl>ROM<hl></hl>中值的地址。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr</span> <span class="built_in">r0</span>,[DAT_02090fe8]</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="symbol">DAT_02090fe8</span></span><br><span class="line">  <span class="number">02000010</span></span><br></pre></td></tr></tbody></table></figure><p>这将把值<hl></hl>0x2000010<hl></hl>加载到<hl></hl><code>r0</code><hl></hl>中。</p><blockquote><p>为了方便，Ghidra<hl></hl>使用<hl></hl><code>DAT_&lt;address&gt;</code><hl></hl>标记数据值。在底层，<code>ldr</code><hl></hl>指令包含从指令在<hl></hl>ROM<hl></hl>中的地址到数据值地址的<hl></hl>13<hl></hl>位有符号偏移量。</p></blockquote><h4 id="分支">分支</h4><p>到目前为止，所有指令都是按顺序逐行执行的。程序执行一条指令，程序计数器加<hl></hl>4（每条指令占<hl></hl>4<hl></hl>个字节），然后执行内存中的下一条指令，依此类推。例如，如果程序计数器的初始值为<hl></hl>0x2000000，程序执行顺序如下：</p><ol type="1"><li>执行地址为<hl></hl>0x2000000<hl></hl>的指令。</li><li>将程序计数器增加到<hl></hl>0x2000004。</li><li>执行地址为<hl></hl>0x2000004<hl></hl>的指令。</li><li>将程序计数器增加到<hl></hl>0x2000008。</li><li>执行地址为<hl></hl>0x2000008<hl></hl>的指令。</li></ol><p>如此继续。</p><p>分支指令（也被称为条件语句或跳转）可以将程序计数器设置为特定的值，从而使程序执行跳转到指定的指令。</p><p>以下是一条无条件分支指令。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">b</span> LAB_02090fdc</span><br></pre></td></tr></tbody></table></figure><p><code>LAB_02090fdc</code><hl></hl>被称为<strong>标签</strong>。标签表示内存中的某条指令。在本例中，标签指的是<hl></hl>ROM<hl></hl>中地址为<hl></hl>0x2090FDC<hl></hl>的指令。</p><p>以上例为例，如果分支指令位于地址<hl></hl>0x2000004：</p><ol type="1"><li>执行地址为<hl></hl>0x2000000<hl></hl>的指令。</li><li>将程序计数器增加到<hl></hl>0x2000004。</li><li>执行地址为<hl></hl>0x2000004<hl></hl>的<hl></hl><code>b LAB_02090fdc</code><hl></hl>指令。</li><li>分支指令将程序计数器设置为<hl></hl>0x2090FDC。</li><li>执行地址为<hl></hl>0x2090FDC<hl></hl>的指令。</li><li>将程序计数器增加到<hl></hl>0x2090FE0。</li><li>执行地址为<hl></hl>0x2090FE0<hl></hl>的指令。</li></ol><p>如此继续。分支之后，程序计数器继续按顺序增加并执行指令。</p><blockquote><p>与数据值类似，分支指令在底层包含从指令地址到跳转目标的偏移量。对于分支指令，偏移量长度为<hl></hl>26<hl></hl>位。</p></blockquote><p>除了<hl></hl><code>b</code><hl></hl>指令，还有其他无条件分支指令用于特定情况：</p><ul><li><code>bl</code>：用于函数调用的分支指令，稍后将讨论。</li><li><code>bx</code>：把寄存器的值作为地址跳转。</li></ul><h4 id="条件分支">条件分支</h4><p>可以编写仅在满足某个条件时才执行的分支指令。如果条件不满足，条件分支指令将被跳过，程序计数器递增并继续执行下一条指令。</p><p>条件分支由两条指令组成。以下是一个示例。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span>   <span class="built_in">r0</span>, <span class="number">#0x1</span></span><br><span class="line"><span class="keyword">beq</span>   LAB_02090f14</span><br></pre></td></tr></tbody></table></figure><p>在这一组指令中，如果<hl></hl><code>r0</code><hl></hl>的值等于<hl></hl>1，则程序跳转到<hl></hl><code>LAB_02090f14</code>。如果<hl></hl>r0<hl></hl>不等于<hl></hl>1，程序将跳过分支并执行下一条指令。</p><ul><li><code>cmp</code><hl></hl>指令比较两个值来设置条件分支。第一个值始终是寄存器，第二个值可以是立即数也可以是另一个寄存器。</li><li>所有条件分支指令都以字母’b’<hl></hl>开头，并以一个<strong>助记符扩展</strong>（也即<strong>条件码</strong>）结尾，指定需要满足的条件类型。在本例中，扩展<hl></hl><code>eq</code><hl></hl>表示如果比较值相等，则执行分支。</li></ul><p>条件分支指令支持所有基本的比较操作符：</p><ul><li>等于：<code>beq</code></li><li>不等于：<code>bne</code></li><li>大于：<code>bgt</code>，<code>bhi</code></li><li>大于等于：<code>bge</code>，<code>bcs</code></li><li>小于：<code>blt</code>，<code>bcc</code></li><li>小于等于：<code>ble</code>，<code>bls</code></li></ul><p>等于和不等于各有一条指令，而其他比较操作符有不同的版本，以支持无符号整数、有符号整数和浮点数的比较。每个比较操作符的条件码的完整列表可以在<hl></hl><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ddi0406/cb/Application-Level-Architecture/Instruction-Details/Conditional-execution">ARM<hl></hl>的开发者文档</a>中找到。</p><p>ARM<hl></hl>还支持单个指令的简化形式的条件分支。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span>   <span class="built_in">r0</span>, <span class="number">#0x1</span></span><br><span class="line"><span class="keyword">moveq</span> <span class="built_in">r0</span>, <span class="built_in">r1</span></span><br></pre></td></tr></tbody></table></figure><p>与普通条件分支一样，<code>cmp</code><hl></hl>指令用于设置分支。在<hl></hl><code>cmp</code><hl></hl>之后，下一条指令不是<hl></hl><code>b</code><hl></hl>指令，而是附加了条件码的其他指令。在上述示例中，只有当<hl></hl><code>r0</code><hl></hl>等于<hl></hl>1<hl></hl>时，<code>r0</code><hl></hl>才会被赋值为<hl></hl><code>r1</code>。所有指令都允许附加条件码。</p><p>像<hl></hl>C<hl></hl>这样的高级语言使用条件关键字如<hl></hl><code>if</code>/<code>else if</code>/<code>else</code><hl></hl>和循环关键字如<hl></hl><code>while</code>/<code>do while</code>/<code>for</code>。这些结构通常在编译为汇编代码时转换为条件分支语句。</p><blockquote><p>在<hl></hl>CPU<hl></hl>内部，<code>cmp</code><hl></hl>指令设置了四个位的<strong>条件标志</strong>，分别为<hl></hl>C、N、V<hl></hl>和<hl></hl>Z。每条条件分支指令都检查特定的条件标志以决定是否执行分支。例如，<code>beq</code><hl></hl>指令会在<hl></hl>Z=1<hl></hl>时执行分支。你很可能不需要直接与这些条件标志交互，了解条件码就足够了。</p></blockquote><h3 id="函数">函数</h3><p>在概念层面，汇编中的函数与高级语言中的函数类似。一个函数可以被调用，然后该函数运行，最后返回到调用该函数的代码。函数还可以有参数和返回值。让我们更深入地了解汇编中的函数是如何工作的。</p><p>一个函数可以通过如下方式调用：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bl</span> FUN_022de288</span><br></pre></td></tr></tbody></table></figure><p><code>bl</code><hl></hl>是一条用于函数调用的特殊分支指令。在这种情况下，程序将跳转到函数<hl></hl><code>FUN_022de288</code><hl></hl>的第一条指令。在分支之前，程序计数器的当前值会被保存到<strong>链接寄存器<hl></hl></strong>(link register, <code>lr</code>)，对于<hl></hl>NDS<hl></hl>的<hl></hl>CPU，<code>lr</code><hl></hl>就是<hl></hl><code>r14</code>。函数结束时将检索链接寄存器的值，以便将程序返回到调用函数的位置。</p><p>下面是一个简单的函数：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">FUN_022de288</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ldr</span>   <span class="built_in">r0</span>, [<span class="built_in">r0</span>, <span class="number">#0x0</span>]</span><br><span class="line"><span class="keyword">bx</span>    <span class="built_in">lr</span></span><br></pre></td></tr></tbody></table></figure><p>默认情况下，Ghidra<hl></hl>根据函数开始的内存地址命名函数。此函数从内存地址<hl></hl>0x22DE288<hl></hl>开始，因此该函数被命名为<hl></hl><code>FUN_022de288</code>。</p><p>大多数函数包含三部分：<strong>序幕</strong>、<strong>主体</strong>和<strong>尾声</strong>。序幕和尾声分别包括函数执行的标准设置和清理步骤，而主体是函数执行的主要逻辑。在上述函数中：</p><ul><li>该函数简单到没有序幕。</li><li>主体包含指令<hl></hl><code>ldr r0, [r0, #0x0]</code>。</li><li>尾声包含指令<hl></hl><code>bx lr</code>。该指令将<hl></hl><code>pc</code><hl></hl>设置为<hl></hl><code>lr</code><hl></hl>中的值，于是程序将返回到调用该函数的地方。</li></ul><p>一旦函数从尾声返回到调用函数，<code>pc</code><hl></hl>会像往常一样递增，于是程序在函数调用后直接执行下一条指令。</p><h4 id="函数参数">函数参数</h4><p>要将参数传递给函数，需要在调用函数之前将参数存储在寄存器中。<code>r0</code>-<code>r3</code><hl></hl>可用于传递参数。如果函数需要超过四个参数，任何其他参数会被压进栈里，稍后再讨论。</p><p>在下面的代码中，给<hl></hl><code>r0</code><hl></hl>赋值以作为参数传递给<hl></hl><code>FUN_022de288</code>。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">r0</span>, <span class="built_in">r4</span>, <span class="number">#0x0</span></span><br><span class="line"><span class="keyword">bl</span>    FUN_022de288</span><br></pre></td></tr></tbody></table></figure><p>一旦进入函数，函数就可以使用来自<hl></hl><code>r0</code><hl></hl>的参数。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">FUN_022de288</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ldr</span> <span class="built_in">r0</span>, [<span class="built_in">r0</span>, <span class="number">#0x0</span>]</span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></tbody></table></figure><h4 id="返回值">返回值</h4><p>如果函数需要返回一个值，返回值将在函数返回之前存储在<hl></hl><code>r0</code><hl></hl>中。调用函数可以根据需要使用<hl></hl><code>r0</code><hl></hl>中的返回值。</p><p>在函数<hl></hl><code>FUN_022de288</code><hl></hl>中，函数体在返回时将一个值赋给<hl></hl><code>r0</code>，然后用<hl></hl><code>bx</code><hl></hl>返回。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">FUN_022de288</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ldr</span>   <span class="built_in">r0</span>, [<span class="built_in">r0</span>, <span class="number">#0x0</span>]</span><br><span class="line"><span class="keyword">bx</span>    <span class="built_in">lr</span></span><br></pre></td></tr></tbody></table></figure><p>调用者可以调用该函数，然后从<hl></hl><code>r0</code><hl></hl>中检索返回值以用于处理。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bl</span>    FUN_022de288</span><br><span class="line"><span class="keyword">cmp</span>   <span class="built_in">r0</span>, <span class="number">#0x1</span></span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></tbody></table></figure><h4 id="调用栈">调用栈</h4><p>当调用一个函数时，调用者可能已经在使用寄存器来存储值。寄存器数量有限，函数也可能需要这些寄存器来完成其工作。在函数使用寄存器之前，它应该保存它计划使用的寄存器的现有值。当函数完成时，它应该将保存的值恢复到寄存器中，这样调用者在恢复执行时不会丢失当前状态。</p><p>寄存器<hl></hl><code>r0</code>-<code>r3</code><hl></hl>和<hl></hl><code>r12</code><hl></hl>被指定为<strong>临时寄存器</strong>，使用它们的函数不保存它们的值。而寄存器<hl></hl><code>r4</code>-<code>r11</code><hl></hl>是<strong>保留寄存器</strong>（或<strong>变量寄存器</strong>），它们的值需要由函数保存和恢复。如果函数调用其他函数，则还会保存<hl></hl><code>lr</code>（译注：也就是<hl></hl><code>r14</code>）。</p><p>由于一个函数可以调用另一个函数，而该函数又可以调用另一个函数，如此反复，所以每个函数都必须在适当的时间存储和恢复寄存器的值。这是通过使用被称为调用栈（call stack）的内存位置来完成的。</p><p><strong>调用栈</strong>，通常简称为<strong>栈</strong>，是内存中的一个特殊位置，用于在函数调用时保存寄存器的值。如果寄存器中没有足够的空间，它还用于存储局部变量。顾名思义，它是一个先进后出的（LIFO）数据结构。栈顶的地址由<hl></hl><code>r13</code><hl></hl>跟踪，通常被称为<strong>栈指针<hl></hl></strong>(<code>sp</code>)。</p><p>函数序幕的主要目的之一就是将寄存器的值保存到栈中。寄存器的值通过<hl></hl><code>stmdb</code>（store multiple, decrement before）指令压到栈顶（即<hl></hl><code>sp</code><hl></hl>的地址），也可记作<hl></hl><code>push</code><hl></hl>指令。此指令用于将多个寄存器的值存储在连续的地址中：递减栈指针，存储第一个值，再次递减栈指针，依此类推。</p><p>以下是一个序幕示例，保存了寄存器的值。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stmdb</span> <span class="built_in">sp</span>!, {<span class="built_in">r4</span> <span class="built_in">lr</span>}</span><br></pre></td></tr></tbody></table></figure><p>该序幕取自一个使用<hl></hl><code>r4</code><hl></hl>进行计算的函数。该函数还调用了另一个带有<hl></hl><code>bl</code><hl></hl>指令的函数，这将覆盖<hl></hl><code>lr</code><hl></hl>中的现有值。因此，该函数必须将当前的<hl></hl><code>r4</code><hl></hl>和<hl></hl><code>lr</code><hl></hl>的值保存到栈中。</p><p>在函数尾声中，通过使用<hl></hl><code>ldmia</code>（load multiple, increment after）指令，也可记作<hl></hl><code>pop</code>，将保存的寄存器值恢复到原始值。这是上面序幕对应的尾声。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldmia</span> <span class="built_in">sp</span>!, {<span class="built_in">r4</span> <span class="built_in">pc</span>}</span><br></pre></td></tr></tbody></table></figure><p><code>ldmia</code><hl></hl>会删除栈顶的值并将它们分配给指定的寄存器。<code>ldmia</code><hl></hl>还会递增<hl></hl><code>sp</code>，使栈顶移动到已经出栈的项之后。在上述示例中，<code>r4</code><hl></hl>恢复为其原始值。<code>pc</code><hl></hl>被分配给最初从<hl></hl><code>lr</code><hl></hl>保存的值，使程序跳回到调用者函数的捷径。</p><p>除了保存和恢复寄存器值之外，栈还有几个其他用途。</p><h5 id="栈中的局部变量">栈中的局部变量</h5><p>如果一个函数有很多局部变量，或者像结构体、数组这样的大型局部变量，可能会耗尽寄存器来存储所有变量。如果发生这种情况，溢出的值都将存储在栈中。如下代码展示了这种情况。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub</span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x1c</span></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">str</span>   <span class="built_in">r0</span>, [<span class="built_in">sp</span>, <span class="number">#0x4</span>]</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#0x1c</span></span><br></pre></td></tr></tbody></table></figure><p>在函数序幕中，栈指针被减去<hl></hl><code>0x1c</code>，为局部变量腾出空间。函数通过使用相对于<hl></hl><code>sp</code><hl></hl>的偏移量在栈中存储和加载局部变量。在函数尾声中，函数通过将值加回<hl></hl><code>sp</code><hl></hl>来清理分配的局部变量空间。</p><p>Ghidra<hl></hl>根据栈中的局部变量在栈中的位置分配名称，如<hl></hl><code>local_24</code>，而不是显示相对于<hl></hl><code>sp</code><hl></hl>的原始偏移量。该数字是通过将局部变量区域的总大小（0x1c）减去变量的偏移量（0x4）得出的，然后转换为十进制。0x1c - 0x4 = 0x18 = 24。</p><h5 id="栈中的函数参数">栈中的函数参数</h5><p>有四个寄存器可用于函数传参。如果函数需要超过四个参数，额外的参数将被存储在栈中进行传递。栈也用于传递较大的数据类型，如结构体和数组。</p><p>下面是一个向函数传递五个参数的例子。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Prologue</span></span><br><span class="line"><span class="keyword">sub</span>   <span class="built_in">sp</span>, <span class="number">#0x4</span></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="comment">; Body</span></span><br><span class="line"><span class="keyword">str</span>   <span class="built_in">r2</span>, [<span class="built_in">sp</span>, <span class="number">#0x0</span>]</span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">r0</span>, <span class="built_in">r5</span>, <span class="number">#0x0</span></span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">r1</span>, <span class="built_in">r4</span>, <span class="number">#0x0</span></span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">r2</span>, <span class="built_in">r9</span></span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">r3</span>, <span class="built_in">r6</span>, <span class="number">#0x0</span></span><br><span class="line"><span class="keyword">bl</span>    FUN_02332bac</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="comment">; Epilogue</span></span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">sp</span>, <span class="number">#0x4</span></span><br></pre></td></tr></tbody></table></figure><p>与栈中的局部变量一样，序幕通过从<hl></hl><code>sp</code><hl></hl>中减去值来为在栈中传递的函数参数分配栈空间。当调用函数<hl></hl><code>FUN_02332bac</code><hl></hl>时，<code>r0</code>-<code>r3</code><hl></hl>用于四个参数，栈用于最后一个参数（使用<hl></hl><code>str r2, [sp, #0x0]</code><hl></hl>设置）。尾声通过将值加回<hl></hl><code>sp</code><hl></hl>来清理栈空间。</p><p>在<hl></hl><code>FUN_02332bac</code><hl></hl>函数内部，函数根据栈参数相对于<hl></hl><code>sp</code><hl></hl>的偏移量进行访问。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">FUN_02332bac</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">ldr</span> <span class="built_in">r0</span>,[<span class="built_in">sp</span>, <span class="symbol">#Stack</span>[<span class="number">0x0</span>]]</span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></tbody></table></figure><p>以上关于传递参数、返回值、保存寄存器和分配局部变量的模式都是<hl></hl>ARM <strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Calling_convention">调用约定</a></strong>的一部分。这是一组标准，指导在函数调用时汇编代码应如何使用寄存器和内存，以确保程序的正确执行。如果你编写更高级别的代码（如<hl></hl>C<hl></hl>语言），编译器会生成符合调用约定的汇编代码。如果你手动编写汇编代码，尽管没有什么阻止你违反这种约定，但偏离约定是不好的做法，且很容易导致错误。</p><h3 id="结构体">结构体</h3><p>分析汇编代码，可以判断出像<hl></hl>C<hl></hl>这样高级语言中的结构体是如何编译成汇编代码的。</p><p>在<hl></hl>C<hl></hl>中，一个结构体定义可能如下所示。对于本教程，假设<hl></hl><code>int</code><hl></hl>的大小为<hl></hl>4<hl></hl>字节：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Position</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个结构体的大小是<hl></hl>8<hl></hl>字节。由于<hl></hl><code>x</code><hl></hl>是结构体中定义的第一个变量，所以它位于结构体的开始处（即偏移量为<hl></hl>0）。 <code>x</code><hl></hl>占用<hl></hl>4<hl></hl>字节，因此下一个变量<hl></hl><code>y</code><hl></hl>的偏移量为<hl></hl>4，从结构体的开始处计算。</p><p>典型的汇编代码会维护一个指向结构体开始位置的指针，并使用偏移量来访问结构体的每个字段。以下代码是将值存储到结构体中的一个示例。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr</span>   <span class="built_in">r0</span>, [DAT_02073b70]  <span class="comment">; Load the address of a Position.</span></span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">r1</span>, <span class="number">#0x6</span></span><br><span class="line"><span class="keyword">str</span>   <span class="built_in">r1</span>, [<span class="built_in">r0</span>, <span class="number">#0x0</span>]      <span class="comment">; position.x = 6;</span></span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">r1</span>, <span class="number">#0x4</span></span><br><span class="line"><span class="keyword">str</span>   <span class="built_in">r1</span>, [<span class="built_in">r0</span>, <span class="number">#0x4</span>]      <span class="comment">; position.y = 4;</span></span><br></pre></td></tr></tbody></table></figure><p>在逆向工程社区中，常见的情况是有一个结构体字段，但是用途尚不明确。社区通常会根据未知的字段的偏移量命名。例如，如果上面的结构体还没有被识别为存储位置信息的结构体，它可能会使用类似如下的命名：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unkStruct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> unk0;</span><br><span class="line">    <span class="type">int</span> unk4;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="复制结构体数据">复制结构体数据</h4><p>对结构体的一种常见操作是将值从一个结构体复制到另一个结构体。有一些特殊的指令可以批量加载和存储值：<code>ldmia</code><hl></hl>和<hl></hl><code>stmia</code>。我们已经在入栈和出栈时见过类似的指令，现在让我们更详细地了解它们。</p><p><code>ldmia</code><hl></hl>指令代表<hl></hl>“load multiple, increment after”，形式如下：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldmia</span> <span class="built_in">r1</span>!, {<span class="built_in">r3</span> <span class="built_in">r4</span> <span class="built_in">r5</span>}</span><br></pre></td></tr></tbody></table></figure><p><code>r1</code><hl></hl>存储初始的加载数据的地址。对于方括号中的每个寄存器，4<hl></hl>字节的数据将从<hl></hl><code>r1</code><hl></hl>的地址加载到寄存器中，然后<hl></hl><code>r1</code><hl></hl>递增<hl></hl>4。这将导致从<hl></hl><code>r1</code><hl></hl>中的地址加载<hl></hl>12<hl></hl>字节的数据到寄存器<hl></hl><code>r3</code>、<code>r4</code><hl></hl>和<hl></hl><code>r5</code>。</p><p>例如，如果<hl></hl><code>r1</code><hl></hl>最初存储地址<hl></hl>0x2000000，<code>ldmia</code><hl></hl>指令将执行以下操作：</p><ul><li>将地址<hl></hl>0x2000000<hl></hl>处的值加载到<hl></hl><code>r3</code>。</li><li>将<hl></hl><code>r1</code><hl></hl>递增到<hl></hl>0x2000004。</li><li>将地址<hl></hl>0x2000004<hl></hl>处的值加载到<hl></hl><code>r4</code>。</li><li>将<hl></hl><code>r1</code><hl></hl>递增到<hl></hl>0x2000008。</li><li>将地址<hl></hl>0x2000008<hl></hl>处的值加载到<hl></hl><code>r5</code>。</li><li>将<hl></hl><code>r1</code><hl></hl>递增到<hl></hl>0x200000C。</li></ul><p>也可以传递一组寄存器范围来进行加载，而不是列出每个单独的寄存器。</p><blockquote><p>指令中的<hl></hl>“!”<hl></hl>表示<hl></hl>“写回模式”，这意味着源寄存器会被指令递增。在某些指令集中，可以省略<hl></hl>“!”<hl></hl>以保持源寄存器不变。</p></blockquote><p><code>stmia</code><hl></hl>指令（store multiple, increment after）的工作方式与<hl></hl><code>ldmia</code><hl></hl>类似，只不过它将每个方括号中的寄存器的值存储到一个地址中。与<hl></hl><code>ldmia</code><hl></hl>一样，<code>stmia</code><hl></hl>可以接受一个寄存器列表或寄存器范围。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stmia</span> <span class="built_in">r2</span>!, {<span class="built_in">r3</span> <span class="built_in">r4</span> <span class="built_in">r5</span>}</span><br></pre></td></tr></tbody></table></figure><p>如果<hl></hl><code>r2</code><hl></hl>最初存储地址<hl></hl>0x2000000，<code>stmia</code><hl></hl>指令将执行以下操作：</p><ul><li>将<hl></hl><code>r3</code><hl></hl>中的值存储到地址<hl></hl>0x2000000。</li><li>将<hl></hl><code>r2</code><hl></hl>递增到<hl></hl>0x2000004。</li><li>将<hl></hl><code>r4</code><hl></hl>中的值存储到地址<hl></hl>0x2000004。</li><li>将<hl></hl><code>r2</code><hl></hl>递增到<hl></hl>0x2000008。</li><li>将<hl></hl><code>r5</code><hl></hl>中的值存储到地址<hl></hl>0x2000008。</li><li>将<hl></hl><code>r2</code><hl></hl>递增到<hl></hl>0x200000C。</li></ul><p>在<hl></hl><code>ldmia</code><hl></hl>和<hl></hl><code>stmia</code><hl></hl>中，递增后的寄存器地址最终位于加载<hl></hl>/<hl></hl>存储的最后一个值的下一个地址。这使得可以链接<hl></hl><code>ldmia</code>/<code>stmia</code><hl></hl>以复制任意大小的数据。指令链可能如下所示：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldmia</span>   <span class="built_in">r1</span>!, {<span class="built_in">r3</span> <span class="built_in">r4</span> <span class="built_in">r5</span>}</span><br><span class="line"><span class="keyword">stmia</span>   <span class="built_in">r2</span>!, {<span class="built_in">r3</span> <span class="built_in">r4</span> <span class="built_in">r5</span>}</span><br><span class="line"><span class="keyword">ldmia</span>   <span class="built_in">r1</span>!, {<span class="built_in">r3</span> <span class="built_in">r4</span> <span class="built_in">r5</span>}</span><br><span class="line"><span class="keyword">stmia</span>   <span class="built_in">r2</span>!, {<span class="built_in">r3</span> <span class="built_in">r4</span> <span class="built_in">r5</span>}</span><br></pre></td></tr></tbody></table></figure><p>这些指令将从<hl></hl><code>r1</code><hl></hl>中的地址复制<hl></hl>24<hl></hl>字节的数据到<hl></hl><code>r2</code><hl></hl>中的地址。</p><p>使用<hl></hl><code>ldmia</code><hl></hl>和<hl></hl><code>stmia</code><hl></hl>从一个结构体复制数据到另一个结构体所需的指令要比逐个复制每个字段的指令少得多。</p><h3 id="数组">数组</h3><p>在汇编中，有几种方式可以实现数组的访问。</p><p>在很多方面，数组与结构体类似。如果访问一个硬编码的数组索引（即循环外的访问），会使用偏移量来访问数据，类似于结构体。复制数组数据也类似于复制结构体，通常使用相同的<hl></hl><code>ldmia</code>/<code>stmia</code><hl></hl>指令链。</p><p>如果在循环中访问数组，仍然可以使用偏移量，只不过每个数组元素的偏移量必须递增或重新计算。以下示例遍历了一个包含<hl></hl>5<hl></hl>个<hl></hl>4<hl></hl>字节值（例如指针）的数组。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr</span>   <span class="built_in">r2</span>, [DAT_02073b70]  <span class="comment">; Load pointer to start of array.</span></span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">r6</span>, <span class="number">#0x0</span>            <span class="comment">; Initialize array index.</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LAB_02073ac0</span></span><br><span class="line"><span class="keyword">lsl</span>   <span class="built_in">r1</span>, <span class="built_in">r6</span>, <span class="number">#0x2</span>  <span class="comment">; Calculate array offset by left-shifting by 2 (multiplying by 4).</span></span><br><span class="line"><span class="keyword">ldr</span>   <span class="built_in">r0</span>, [<span class="built_in">r2</span>, <span class="built_in">r1</span>]  <span class="comment">; Load current array element.</span></span><br><span class="line"><span class="symbol">...</span>                 <span class="comment">; Process current array element.</span></span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">r6</span>, <span class="number">#0x1</span>      <span class="comment">; Increment array index.</span></span><br><span class="line"><span class="keyword">cmp</span>   <span class="built_in">r6</span>, <span class="number">#0x5</span></span><br><span class="line"><span class="keyword">ble</span>   LAB_02073ac0  <span class="comment">; Go back to loop start if iteration is not finished.</span></span><br></pre></td></tr></tbody></table></figure><p>另一种方式是从数组指针初始化当前数组元素的指针并递增。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr</span>   <span class="built_in">r2</span>, [DAT_02073b70]  <span class="comment">; Load pointer to start of array.</span></span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">r6</span>, <span class="number">#0x0</span>            <span class="comment">; Initialize array index.</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">LAB_02073ac0</span></span><br><span class="line"><span class="keyword">ldr</span>   <span class="built_in">r0</span>, [<span class="built_in">r2</span>, <span class="number">#0x0</span>]  <span class="comment">; Load current array element.</span></span><br><span class="line"><span class="symbol">...</span>                   <span class="comment">; Process current array element.</span></span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">r6</span>, <span class="number">#0x1</span>        <span class="comment">; Increment array index.</span></span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">r2</span>, <span class="number">#0x4</span>        <span class="comment">; Increment current array element pointer.</span></span><br><span class="line"><span class="keyword">cmp</span>   <span class="built_in">r6</span>, <span class="number">#0x5</span></span><br><span class="line"><span class="keyword">ble</span>   LAB_02073ac0    <span class="comment">; Go back to loop start if iteration is not finished.</span></span><br></pre></td></tr></tbody></table></figure><h3 id="switch语句">Switch<hl></hl>语句</h3><p>在汇编中，switch<hl></hl>语句通常使用<strong>跳转表</strong>实现。汇编中存储了一系列<hl></hl><code>b</code><hl></hl>指令，传入<hl></hl>switch<hl></hl>语句的值会加到<hl></hl><code>pc</code><hl></hl>中，以跳转到相应的<hl></hl><code>b</code><hl></hl>指令，然后跳转到处理该<hl></hl>case<hl></hl>的逻辑。</p><p>例如，让我们看一个简单的<hl></hl>C<hl></hl>语言<hl></hl>switch<hl></hl>语句：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> type;</span><br><span class="line"><span class="comment">// Logic to assign type variable</span></span><br><span class="line"><span class="keyword">switch</span> (type)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="comment">// Logic to handle case.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// Logic to handle case.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="comment">// Logic to handle case.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的<hl></hl>switch<hl></hl>语句在汇编中可能如下所示：</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Logic to assign r0 (type variable).</span></span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">  <span class="keyword">cmp</span>   <span class="built_in">r0</span>, <span class="number">#0x5</span></span><br><span class="line">  <span class="keyword">addls</span> <span class="built_in">pc</span>, <span class="built_in">pc</span>, <span class="built_in">r1</span>, <span class="keyword">lsl</span> <span class="number">#0x2</span>      <span class="comment">; Multiply type by 4 to get jump table offset to branch instruction.</span></span><br><span class="line">  <span class="keyword">b</span>     switchD_02334050::caseD_6 <span class="comment">; Go to end of function and do nothing if value is out of range.</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">switchD_02334050:</span>:caseD_0</span><br><span class="line">  <span class="keyword">b</span>     LAB_023344e8</span><br><span class="line"><span class="symbol">switchD_02334050:</span>:caseD_1</span><br><span class="line">  <span class="keyword">b</span>     LAB_023344e8</span><br><span class="line"><span class="symbol">switchD_02334050:</span>:caseD_2</span><br><span class="line">  <span class="keyword">b</span>     LAB_023344d0</span><br><span class="line"><span class="symbol">switchD_02334050:</span>:caseD_3</span><br><span class="line">  <span class="keyword">b</span>     LAB_023344d0</span><br><span class="line"><span class="symbol">switchD_02334050:</span>:caseD_4</span><br><span class="line">  <span class="keyword">b</span>     LAB_02334510</span><br><span class="line"><span class="symbol">switchD_02334050:</span>:caseD_5</span><br><span class="line">  <span class="keyword">b</span>     LAB_023344d0</span><br></pre></td></tr></tbody></table></figure><p>有些<hl></hl>switch<hl></hl>语句会放弃使用跳转表，而是使用一系列条件分支，有时也会将这两种方法结合使用。</p><h3 id="汇编入门总结">汇编入门总结</h3><p>读到这里，你现在已经具备了阅读<hl></hl>NDS<hl></hl>的<hl></hl>ARM<hl></hl>汇编代码的基础知识，并能识别一些最常见的汇编模式。虽然本教程没有涵盖一些不常见的汇编操作和模式，但你应该已经有足够的上下文来通过文档<hl></hl>(例如<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference?lang=en">官方<hl></hl>ARM<hl></hl>文档</a>、<a target="_blank" rel="noopener" href="https://www.coranac.com/tonc/text/asm.htm#sec-arm">Tonc</a>)<hl></hl>和你喜欢的搜索引擎来补充这些知识。与大多数技能一样，练习是提高汇编阅读能力的最佳方法。</p><p>下一步是探索一些能帮助逆向工程<hl></hl>NDS<hl></hl>游戏的工具。我们将从静态代码分析器<hl></hl>Ghidra<hl></hl>开始。</p><p class="fin"><a href="/notes/2024/10/03/%E5%A6%82%E4%BD%95%E9%80%86%E5%90%91NDS%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%8B%EF%BC%89/">to <span style="color:blue">B</span><span style="color:red">e</span> continued -&gt;</a></p></div></article><aside class="post-widget"><h4>目录<hl></hl></h4><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8"><span class="post-toc-number">1.</span> <span class="post-toc-text">汇编入门<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">寄存器<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">内存<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#rom"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">ROM</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#overlay"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">overlay</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9F%A5%E6%89%BEoverlay"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">查找<hl></hl>overlay</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">指令<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">赋值<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%97%E6%9C%AF"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">算术<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%AD%98%E5%82%A8%E5%86%85%E5%AD%98"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">加载<hl></hl>/<hl></hl>存储内存<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E6%94%AF"><span class="post-toc-number">1.5.4.</span> <span class="post-toc-text">分支<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="post-toc-number">1.5.5.</span> <span class="post-toc-text">条件分支<hl></hl></span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">函数<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">函数参数<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">返回值<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B0%83%E7%94%A8%E6%A0%88"><span class="post-toc-number">1.6.3.</span> <span class="post-toc-text">调用栈<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%A0%88%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="post-toc-number">1.6.3.1.</span> <span class="post-toc-text">栈中的局部变量<hl></hl></span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%A0%88%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="post-toc-number">1.6.3.2.</span> <span class="post-toc-text">栈中的函数参数<hl></hl></span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">结构体<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%8D%E5%88%B6%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">复制结构体数据<hl></hl></span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">数组<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">Switch<hl></hl>语句<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">汇编入门总结<hl></hl></span></a></li></ol></li></ol></nav></aside></div><footer class="footer-nav"><div class="footer"><div class="back-top" id="back-top" title="Back to top"><i class="icon icon-chevron-bar-up"></i></div><div class="footer-content"><div class="footer-links"><div class="footer-links-column"><p><a title="Google Scholar" target="_blank" rel="noopener" href="https://scholar.google.com/">Google Scholar</a></p><p><a title="Google patents" target="_blank" rel="noopener" href="https://patents.google.com/">Google patents</a></p><p><a title="Bing Academic" target="_blank" rel="noopener" href="https://bing.com/academic/">Bing Academic</a></p></div><div class="footer-links-column"><p><a title="Web of Science" target="_blank" rel="noopener" href="https://www.webofscience.com/">Web of Science</a></p><p><a title="Science Direct" target="_blank" rel="noopener" href="https://www.sciencedirect.com/">Science Direct</a></p><p><a title="中国知网" target="_blank" rel="noopener" href="https://www.cnki.net/"><hl></hl>中国知网<hl></hl></a></p></div><div class="footer-links-column"><p><a title="arXiv" target="_blank" rel="noopener" href="https://arxiv.org/">arXiv</a></p><p><a title="JSTOR" target="_blank" rel="noopener" href="https://www.jstor.org/">JSTOR</a></p><p><a title="PubMed Central" target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/">PubMed Central</a></p></div><div class="footer-links-column"><p><a title="MSI Eureka" target="_blank" rel="noopener" href="https://search.msi-eureka.com/search">MSI Eureka</a></p><p><a title="GitHub" target="_blank" rel="noopener" href="https://github.com/cerallin/">GitHub</a></p><p><a title="KUKE音乐" target="_blank" rel="noopener" href="https://www.kuke.com/">KUKE<hl></hl>音乐</a></p></div></div><div><span id="site_pv">?</span> PV <span id="site_uv">?</span> UV</div>Copyright © 2021<span class="time-divide">-</span>2026 Cerallin. Power by <a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a> and <a href="https://github.com/Cerallin/hexo-theme-yuzu" target="_blank" rel="external nofollow" title="v3.2.7">Theme Yuzu</a>.</div></div></footer><script>window.config={url_root:"/notes/",meta_path:"meta.json"}</script><script src="/notes/js/theme/back-to-top.js"></script><script src="/notes/js/theme/clipboard.js"></script><script src="/notes/js/theme/loading.js"></script><script src="/notes/js/theme/navbar.js"></script><script src="/notes/js/theme/search.js"></script><script src="/notes/js/theme/toc.js"></script><script src="/notes/js/theme/refs-sidebar.js"></script><script>window.onload=function(){for(var e in Theme)Theme[e].register()}</script></div><div class="search-modal" id="search-modal"><div class="card"><div class="card-head"><div class="search-box"><input class="search-input" id="search-input" placeholder="搜索"><div class="search-button" id="search-button"><div class="icon icon-search"></div></div></div><div class="close-button"><div class="icon icon-x"></div></div></div><div class="card-body"><div class="search-count">共<hl></hl><span id="search-count-num">0</span><hl></hl>条搜索结果。</div><div class="search-result" id="search-result"></div></div></div></div></body></html>