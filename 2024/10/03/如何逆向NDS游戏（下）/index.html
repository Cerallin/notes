<html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="这篇文章介绍了如何使用Ghidra对《宝可梦》NDS游戏进行静态代码分析与注释，并探讨了利用DeSmuME模拟器进行动态调试的方法。文章详述了反编译、内存查看、断点和观察点等工具的具体操作。最后总结了多种逆向工程策略，并推荐了社区资源与工具以辅助研究该游戏。"><title>如何逆向NDS游戏（下）：逆向工程与代码分析 - Cerallin的笔记本 - 瞎折腾～～</title><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="/notes/css/style.css"><link rel="stylesheet" href="/notes/css/helpers.css"><script src="/notes/js/clipboard/clipboard.min.js"></script><script src="/notes/js/bootstrap.js"></script><script>Theme.counter={register:function(){request("//visitor-counter.cerallin.top/count.php/?page="+encodeURI(window.location.href),{method:"GET"}).then(e=>{for(var t in e){var n=document.getElementById(t);n&&(n.innerText=e[t])}}).catch(e=>{console.error("Fetching visit count failed.",e)})}}</script><style>body hl:after {
    content: ' ';
    display: inline;
    font-family: inherit;
    font-size: 0.45em;
}

html code hl,
html pre hl,
html kbd hl,
html samp hl,
html ruby hl,
html .tag-list-item hl {
    display: none;
}

html ol > hl,
html ul > hl {
    display: none;
}</style><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/notes/atom.xml" title="Cerallin的笔记本" type="application/atom+xml"></head><body><div class="loading-wrapper" data-loading="data-loading"><div class="loading"><span></span><span></span><span></span></div></div><div class="page" data-filter="data-filter"><div class="head" data-show="data-show"><header class="head-header"><div class="head-author"><a class="head-author-link" href="/notes/">Cerallin<hl></hl>的笔记本</a></div><div class="head-right"><button class="bar-wrap" id="bar-wrap-toggle" title="菜单按钮"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button><div class="head-item"><a class="search-button head-item-link"><span>搜索</span> <i class="icon icon-search"></i></a></div><div class="head-item"><a class="head-item-link" href="/notes/about">关于</a></div></div></header><div class="menubar-head" id="menubar"><ul class="menubar-ul"><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%B7%A5%E7%A8%8B/">计算机与通信工程</a></li><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E6%9D%90%E6%96%99%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/">材料科学与工程</a></li><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/">瞎折腾</a></li><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E6%B5%85%E6%80%9D/">浅思</a></li><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><i class="icon icon-archive"></i> <a class="menubar-link" href="/notes/archives">归档</a></li><li class="menubar-item"><i class="icon icon-tags"></i> <a class="menubar-link" href="/notes/tags">标签</a></li><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><a class="menubar-link" href="/notes/about"><span>关于</span></a></li></ul><div class="menu-search-box search-button"><div>搜索</div><i class="icon icon-search"></i></div></div></div><div class="main" data-page="post"><article class="post" id="post"><header class="post-head"><h1 class="post-title"><a class="title" href="/notes/2024/10/03/%E5%A6%82%E4%BD%95%E9%80%86%E5%90%91NDS%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%8B%EF%BC%89/">如何逆向<hl></hl>NDS<hl></hl>游戏（下）：逆向工程与代码分析<hl></hl></a></h1></header><div class="post-meta"><div class="post-date"><time class="post-time" itemprop="datePublished" title="2024-10-03 12:34:02" datetime="2024-10-03T04:34:02.000Z">2024-10-03</time></div>|<div class="post-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/ARM/" rel="tag">ARM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/NDS/" rel="tag">NDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/%E6%B1%87%E7%BC%96/" rel="tag"><hl></hl>汇编</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" rel="tag">逆向工程</a></li></ul></div><div class="post-visit"><span id="page_pv">?</span><hl></hl>访问</div></div><div class="post-info"><div class="post-word-count">本文共<hl></hl>9,096<hl></hl>字。</div><div class="post-cc">版权声明：署名 | <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div><div class="article-entry" itemprop="articleBody"><blockquote><p>本文翻译自《<a target="_blank" rel="noopener" href="https://www.starcubelabs.com/reverse-engineering-ds/">Reverse Engineering a DS Game</a>》。</p></blockquote><p>经过两部分的铺垫，终于来到了使用<hl></hl>Ghidra<hl></hl>和<hl></hl>DeSmuME<hl></hl>分别进行静态<hl></hl>/<hl></hl>动态代码分析的实战部分。</p><span id="more"></span><h2 id="使用ghidra">使用<hl></hl>Ghidra</h2><p>Ghidra<hl></hl>是一款功能强大的逆向工程工具，具有丰富的特性。本节将介绍一些<hl></hl>Ghidra<hl></hl>的基本用法，帮助你入门阅读汇编代码。</p><p>Ghidra<hl></hl>界面如下所示：</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/ghidra-ds.png" alt="Ghidra界面，包含两个窗口。"><figcaption aria-hidden="true">Ghidra<hl></hl>界面，包含两个窗口。</figcaption></figure><p>Ghidra<hl></hl>工作区主要有两个。</p><ul><li>中央窗口是<hl></hl><strong>listing</strong>（列表），这里显示的是汇编代码。</li><li>右侧窗口是<hl></hl><strong>decompiler</strong>（反编译），它分析当前选中函数的汇编代码并将其反编译为<hl></hl>C<hl></hl>语言代码。</li></ul><p>Ghidra<hl></hl>界面中还有其他窗口，但本教程不会涉及它们。你可以关闭那些窗口以为列表窗口腾出更多空间。</p><p>在本演示中，我们将使用地址<hl></hl>0x22E0354<hl></hl>处的函数。要导航到此地址，按<hl></hl>‘g’<hl></hl>并输入<hl></hl>“22E0354”。向下滚动一点查看整个函数，结果如下所示：</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/ghidra-example-function-ds.png" alt="FUN_022e0354 in Ghidra"><figcaption aria-hidden="true">FUN_022e0354 in Ghidra</figcaption></figure><p>让我们来分解屏幕上的内容。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/ghidra-example-function-labeled-ds.png" alt="FUN_022e0354 in Ghidra"><figcaption aria-hidden="true">FUN_022e0354 in Ghidra</figcaption></figure><ul><li><strong>函数名称</strong>是显而易见的。</li><li>可以向汇编代码添加注释。<strong>板注释</strong>（plate comment）是占据多行的注释。Ghidra<hl></hl>会自动添加一个板注释来标记函数，当然你也可以自己添加（我们稍后会讨论这个）。</li><li><strong>函数引用</strong>部分列出了汇编代码中调用当前函数的所有位置。列表格式为<hl></hl>“函数名称：指令地址”。在本例中，Ghidra<hl></hl>找到了<hl></hl>4<hl></hl>个调用<hl></hl><code>FUN_022e0354</code><hl></hl>的地方，其中之一是地址<hl></hl>0x22F798C<hl></hl>的<hl></hl><code>bl</code><hl></hl>指令，在<hl></hl><code>FUN_022f7910</code><hl></hl>中。</li><li><strong>汇编指令</strong>就是原始的汇编代码，还包括表示分支目的地和硬编码数据值的<strong>标签</strong>。</li><li><strong>十六进制数据</strong>包含<hl></hl>ROM<hl></hl>文件中与汇编指令对应的原始十六进制值。在<hl></hl><code>FUN_022e0354</code><hl></hl>的开始，<code>ldr r0,[PTR_DAT_022e0958]</code><hl></hl>指令来源于<hl></hl>ROM<hl></hl>中的十六进制值<hl></hl><code>28 00 9f e5</code>。</li><li><strong>地址</strong>包含文件中每条指令的地址或偏移量。<code>FUN_022e0354</code><hl></hl>开始的<hl></hl><code>ldr r0, [PTR_DAT_022e0958]</code><hl></hl>指令位于<hl></hl>ROM<hl></hl>的地址<hl></hl>0x22E0928<hl></hl>处。</li><li><strong>分支</strong>部分包含表示函数内分支的箭头；箭头的起点是分支指令，终点是分支将<hl></hl><code>pc</code><hl></hl>指向的地址。</li><li><strong>标签引用</strong>列出了跳转到每个标签的位置。这里列出了每个跳转指令到给定标签的地址。例如，<code>LAB_022e0948</code><hl></hl>由地址<hl></hl>0x22E0938<hl></hl>的<hl></hl><code>beq</code><hl></hl>指令引用。</li><li><strong>反编译的函数代码</strong>位于反编译器窗口，显示函数的反编译<hl></hl>C<hl></hl>代码。</li></ul><h3 id="反编译器">反编译器</h3><p>反编译器是一种工具，试图将汇编代码反编译为<hl></hl>C<hl></hl>代码。由于<hl></hl>C<hl></hl>语言比汇编语言更高级，有时阅读反编译的<hl></hl>C<hl></hl>代码比汇编代码更快，以理解函数的工作原理。</p><p>有了反编译器，你可能会问：如果汇编代码可以被反编译为<hl></hl>C，为什么还要学习阅读汇编代码呢？</p><ul><li>由于<hl></hl>C<hl></hl>代码是生成的，而不是手动编写的，有时比原始汇编代码更难阅读。</li><li>反编译器并不完美，有时它可能无法反编译某函数。</li><li>在调试正在运行的游戏时，逐行执行的是汇编代码，而不是<hl></hl>C<hl></hl>代码。</li><li>根据你逆向工程的目标不同，通常需要使用汇编而不是反编译的<hl></hl>C<hl></hl>代码。例如，如果你想通过更改代码来为游戏制作补丁，必须通过汇编来完成，除非游戏的逆向工程社区已经创建了将编译的<hl></hl>C<hl></hl>代码注入到<hl></hl>ROM<hl></hl>中的工具，然而这种情况非常少见。</li></ul><p>把反编译器当作工具箱中的另一个工具，而不仅仅依赖它。根据当前的任务需要，你很可能需要在原始汇编代码和反编译的<hl></hl>C<hl></hl>代码之间来回切换阅读。</p><h3 id="导航">导航</h3><p>Ghidra<hl></hl>中有多种导航代码的方法。</p><ul><li>如前所示，按下<hl></hl>‘g’（Go To…）可以跳转到<hl></hl>ROM<hl></hl>中的特定地址。</li><li>双击函数、标签或函数<hl></hl>/<hl></hl>标签的引用，将跳转到<hl></hl>ROM<hl></hl>中的相应位置。</li><li>在<hl></hl>Ghidra<hl></hl>窗口顶部的工具栏上，有按钮用于前进和后退。这些按钮会跟踪你通过<hl></hl>Go To…跳转到不同地址时的历史记录，或者在单击函数和标签时的历史记录。你可以将鼠标悬停在这些按钮上查看它们的键盘快捷键（可能因操作系统不同而有所差异）。</li></ul><h3 id="高亮">高亮</h3><p>Ghidra<hl></hl>允许你高亮某些相应元素，这在瞪眼法检查代码时非常有用。</p><ul><li>单击汇编代码行将高亮相应的反编译<hl></hl>C<hl></hl>代码行。同样，单击<hl></hl>C<hl></hl>代码行将高亮相应的汇编代码。</li><li>中键单击<hl></hl>Ghidra<hl></hl>中的一个符号，将高亮该符号的所有出现位置。例如，你可以中键单击汇编中的<hl></hl><code>r1</code>，高亮该符号的所有其他使用位置。</li><li>右键单击反编译器中的变量，选择<hl></hl>Highlight &gt; Forward Slice or Highlight &gt; Backward Slice，就会高亮数据流动进<hl></hl>/<hl></hl>出选中变量的其他所有变量。</li></ul><h3 id="注释">注释</h3><p>你可以通过右键单击汇编指令并在上下文菜单中转到<hl></hl>Comments，向汇编代码添加注释。你可以选择将注释放置在多个位置，包括行尾（EOL）、行前、行后和板注释。默认键绑定<hl></hl>‘;’<hl></hl>将打开<hl></hl>EOL<hl></hl>注释界面，你还可以在<hl></hl>Edit &gt; Tool Options &gt; Key Bindings<hl></hl>中为其他类型的注释分配键绑定。</p><p>以下是一个行尾注释的示例。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/eol-comment-ds.png" alt="行尾注释"><figcaption aria-hidden="true">行尾注释</figcaption></figure><p>建议多使用注释。汇编中没有描述性变量名，如果不为自己留下笔记，很容易迷失方向。</p><h3 id="标签名称">标签名称</h3><p>一旦你弄清楚函数、分支标签、堆栈值或数据值的作用，就可以通过右键单击标签并点击<hl></hl>Edit label（快捷键<hl></hl>‘L’）来重命名。你也可以在反编译器中编辑变量名。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/rename-label-ds.png" alt="重命名函数的标签"><figcaption aria-hidden="true">重命名函数的标签</figcaption></figure><p>有时，Ghidra<hl></hl>的反汇编器会自动将寄存器标记为参数。这很少有帮助，因为寄存器在函数中会被多次重复使用。要删除这些标签，请转到<hl></hl>Edit &gt; Tool Options…，在打开的菜单中选择<hl></hl>Options &gt; Listing Fields &gt; Operands Field，然后取消选中<hl></hl>Markup Register Variable References（标记寄存器变量引用）。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/register-labels-disable.png" alt="禁用寄存器上的标签"><figcaption aria-hidden="true">禁用寄存器上的标签</figcaption></figure><h3 id="ghidra总结">Ghidra<hl></hl>总结</h3><p>目前为止，我们已经探索了足以开始阅读游戏的汇编代码的<hl></hl>Ghidra<hl></hl>功能。Ghidra<hl></hl>还有许多其他对逆向工程非常有用的功能，你可以自己探索，看看哪些功能对你有用。</p><p>Ghidra<hl></hl>非常适合分析游戏未运行时的代码。虽然这本身已经非常有用，但通过分析游戏运行时的代码来补充它同样有价值。下一节将重点介绍<hl></hl>DeSmuME<hl></hl>的调试功能。</p><h2 id="使用desmume进行调试">使用<hl></hl>DeSmuME<hl></hl>进行调试</h2><p>在逆向工程中，检查游戏运行时的状态通常很有用，这一过程称为<strong>动态代码分析</strong>。主要有查看内存值、逐步执行汇编代码、检查寄存器等。本节将简要介绍<hl></hl>DeSmuME<hl></hl>提供的一些调试功能。</p><h3 id="内存查看器">内存查看器</h3><p>内存查看器可以查看和编辑主内存中的值。可以通过<hl></hl>Tools &gt; View Memory<hl></hl>访问内存查看器，这会弹出一个窗口，如下图所示。请注意，你可以多次选择<hl></hl>View Memory<hl></hl>以打开多个内存查看器窗口。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/memory-viewer-ds.png" alt="内存查看器窗口"><figcaption aria-hidden="true">内存查看器窗口</figcaption></figure><p>在上图中，内存查看器显示了地址<hl></hl>0x2000000<hl></hl>到<hl></hl>0x20000F0<hl></hl>的内存值。字节数据以表格形式显示，地址的第一个数字为列，0x10<hl></hl>的倍数为行。例如，0x2000010<hl></hl>行包含地址<hl></hl>0x2000010<hl></hl>到<hl></hl>0x200001F<hl></hl>的值，而地址<hl></hl>0x2000014<hl></hl>包含值<hl></hl>0xD0。内存查看器默认按单个字节显示，你也可以将视图更改为半字（2<hl></hl>字节）或字（4<hl></hl>字节），以显示更大的值，例如<hl></hl>4<hl></hl>字节的指针。</p><p>在内存表的右侧是数据的字符串表示。浏览用于表示游戏内文本在内存里的部分的时候非常有用，或者用于快速寻找数据的规律。</p><p>你可以点击来选中表中的字节值。然后窗口底部就会（以十进制而不是十六进制）显示该值的有符号<hl></hl>/<hl></hl>无符号整形数值。当选中了一个值时，你也可以更改该值，且会立即反映在游戏中。注意，如果游戏代码里每帧都设置该值，则某些值可能会立即恢复为先前的值。</p><p>你可以通过在顶部的<em>地址</em>中输入地址然后按<em>转到</em>来跳转到内存中的任何地址。窗口将记住你跳转到的最近地址。</p><p>为了演示内存查看器的功能，请跳转到地址<hl></hl>0x21CCB00，该地址包含玩家和伙伴宝可梦的数据。该地址周围的某些值不断变化，这表示游戏中的值在变化。此时，这几个快速变化的值控制着屏幕上宝可梦的动画。如果你在游戏中移动，你会注意到其他变量发生变化，这些变量表示宝可梦在屏幕和迷宫地面上的位置。</p><p>接下来，跳转到地址<hl></hl>0x21BA538。此区域包含与玩家和伙伴宝可梦相关的更多值。将地址为<hl></hl>0x21BA538<hl></hl>处的值更改为<hl></hl>“08”，你会注意到游戏中的玩家生命值（HP）会变成刚刚输入的值。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/edit-memory-ds.png" alt="编辑内存值"><figcaption aria-hidden="true">编辑内存值</figcaption></figure><p>除内存查看器外还有<hl></hl>RAM<hl></hl>监视器，可以通过<hl></hl>Tools &gt; RAM Watch…访问。你可以在此窗口中固定特定的内存地址，以便监视其值。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/ram-watch.png" alt="RAM监视器窗口"><figcaption aria-hidden="true">RAM<hl></hl>监视器窗口</figcaption></figure><h3 id="ram搜索">RAM<hl></hl>搜索</h3><p>RAM<hl></hl>搜索窗口可以在内存中搜索特定值。可以通过<hl></hl>Tools &gt; RAM Search…访问，弹出窗口如下。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/memory-search-ds.png" alt="RAM搜索窗口"><figcaption aria-hidden="true">RAM<hl></hl>搜索窗口</figcaption></figure><p>RAM<hl></hl>搜索是查找与游戏内相关值的地址的重要工具。举个栗子，我们可以搜索<hl></hl>RAM<hl></hl>看看玩家的<hl></hl>HP<hl></hl>存储在哪。</p><p>要搜索某个值，首先输入要搜索的值，然后配置搜索选项，最后点击<hl></hl>Search<hl></hl>按钮。为了搜索玩家当前的<hl></hl>HP，输入我们之前设置好的<hl></hl>“8”。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/memory-search-new-ds.png" alt="搜索值"><figcaption aria-hidden="true">搜索值</figcaption></figure><p>8<hl></hl>是一个较小的值，因此在内存中经常出现。虽然我们可以滚动搜索结果挨个尝试，看看哪个地址代表玩家的<hl></hl>HP，但有更好的方法。</p><p>在不关闭<hl></hl>RAM<hl></hl>搜索的情况下，回到游戏并走动一会儿，直到你的<hl></hl>HP<hl></hl>恢复到<hl></hl>9。接下来，将比较运算符更改为<hl></hl>Different By，在旁边输入<hl></hl>1，然后再次点击<hl></hl>Search。这将会在先前搜索结果里筛选出增加了<hl></hl>1<hl></hl>的所有值。由于上次搜索是值<hl></hl>8，这次将筛选出两次搜索之间从<hl></hl>8<hl></hl>更改为<hl></hl>9<hl></hl>的所有值。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/memory-search-changed-ds.png" alt="搜索变化的值"><figcaption aria-hidden="true">搜索变化的值</figcaption></figure><p>现在搜索结果缩小到了少数几个值，你可以尝试更改这些地址中的每一个值，找到哪个值控制玩家的<hl></hl>HP。最后你会发现正确的地址是<hl></hl>0x21BA538。</p><blockquote><p>为了设置上述示例，我们手动将玩家的<hl></hl>HP<hl></hl>更改为<hl></hl>8，这需要事先知道玩家<hl></hl>HP<hl></hl>的地址。如果你不知道该地址，可以通过游戏内手段降低<hl></hl>HP，例如找到敌人并让它攻击你。</p></blockquote><h3 id="反汇编器">反汇编器</h3><p>在<hl></hl>DeSmuME<hl></hl>中，反汇编器是一个工具，它提供了几项有用的调试功能，可以设置断点以暂停游戏执行，逐步执行汇编代码，查看寄存器值。可以通过<hl></hl>Tools &gt; Disassembler<hl></hl>访问反汇编器，将打开<hl></hl>ARM9<hl></hl>和<hl></hl>ARM7<hl></hl>反汇编器。由于我们要查看的代码是<hl></hl>ARM9 CPU<hl></hl>的代码，请使用<hl></hl>ARM9<hl></hl>反汇编器。（译注：ARM 7<hl></hl>的窗口点击<hl></hl>Close<hl></hl>直接关掉就行）</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/disassembler.png" alt="ARM9反汇编器窗口"><figcaption aria-hidden="true">ARM9<hl></hl>反汇编器窗口</figcaption></figure><h4 id="断点">断点</h4><p>类似于高级语言中的调试器，<strong>breakpoint</strong>（断点）在程序执行到特定行时暂停执行。断点用途广泛，例如用来确定游戏内执行某个动作时是否到达了这一行代码，或者在特定函数中停止程序执行以进行调试。</p><p>作为演示，让我们在函数<hl></hl><code>FUN_022ec7e8</code><hl></hl>的开头设置一个断点。在<hl></hl>Add Breakpoint<hl></hl>按钮下方输入值<hl></hl>“22EC7E8”，然后点击<hl></hl>Add Breakpoint<hl></hl>按钮。现在尝试在游戏中移动角色。程序将试图执行<hl></hl><code>FUN_022ec7e8</code><hl></hl>并命中断点，暂停游戏执行。绿色线条表示即将执行的指令。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/disassembler-hit-breakpoint.png" alt="命中断点"><figcaption aria-hidden="true">命中断点</figcaption></figure><p>图中左侧是汇编代码视图，表示地址和十六进制数据，类似于<hl></hl>Ghidra。你可以通过在<hl></hl>Go to:<hl></hl>中输入地址并点击<hl></hl>GO<hl></hl>来跳转到特定指令。</p><p>汇编视图下方是<hl></hl>Step（步进）和<hl></hl>Cont（继续）按钮，它们的功能类似于标准<hl></hl>IDE<hl></hl>调试器中的功能。步进使程序前进一条指令，如果更改按钮旁边的数字，则前进多条指令。我建议在逐步执行代码时打开<hl></hl>Auto-update，否则每次前进到新指令时都需要点击<hl></hl>Refresh<hl></hl>按钮来更新视图。Cont<hl></hl>将继续程序执行。有时，点击<hl></hl>Cont<hl></hl>之后游戏将保持暂停状态；如果发生这种情况，请使用游戏窗口中的暂停<hl></hl>/<hl></hl>播放按钮（译注：在<hl></hl>File<hl></hl>右边的图形按钮而没有文字）取消暂停。</p><p>汇编视图右侧是寄存器和他们的值，你可以查看并编辑它们。在编辑寄存器值时，请确保禁用了<hl></hl>Auto-update，以避免寄存器值在尝试编辑时立即恢复。完成编辑后，点击更新寄存器以应用寄存器更改。</p><p>窗口右侧是活动断点。注意，如果你点击<hl></hl>Delete breakpoint，当前显示列表顶部的断点将被删除。你可以使用上下箭头按钮滚动列表，将要操作的断点移动到删除位置。</p><p>在我（译注：原作者）的经验里<hl></hl>Run To Return<hl></hl>和<hl></hl>Step over（步过）按钮表现不一致，请自行判断使用。</p><h4 id="监视点">监视点</h4><p><strong>监视点</strong>（watchpoint）会在内存中的特定地址被读取或写入时暂停程序执行。这对于找到代码中操纵内存中特定值的部分非常有用，也可以用来追踪尚未弄清楚用途的内存值。在<hl></hl>DeSmuME<hl></hl>中，监视点包括<strong>读断点</strong>（read breakpoint）和<strong>写断点</strong>（write breakpoint）两种。</p><p>可以在内存查看器中设置监视点。为了演示监视点，我们来监视玩家的<hl></hl>HP<hl></hl>值。打开内存查看器，右侧找到监视点编辑器。在文本框中输入<hl></hl>21BA538，然后点击<hl></hl>Add Write Breakpoint。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/write-breakpoint.png" alt="添加写断点"><figcaption aria-hidden="true">添加写断点</figcaption></figure><p>设置写断点后，移动角色直到<hl></hl>HP<hl></hl>自然恢复。当<hl></hl>HP<hl></hl>恢复时，监视点会暂停程序。进入反汇编器并点击<hl></hl>Refresh<hl></hl>或开启<hl></hl>Auto-update，然后转到当前<hl></hl><code>pc</code><hl></hl>所指向的地址，应该是<hl></hl>0x2311264。向上滚动一些（确保光标不在汇编视图内），找到下一个将要执行的指令的绿色高亮标记，地址是<hl></hl>0x231125C。注意，<code>pc</code><hl></hl>可能比当前执行的指令稍微靠前，这是<hl></hl>CPU<hl></hl>的工作方式导致的。（译注：查阅资料可知，ARM9<hl></hl>有五级流水线）</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/hit-watchpoint.png" alt="玩家HP的写断点命中后的反汇编视图"><figcaption aria-hidden="true">玩家<hl></hl>HP<hl></hl>的写断点命中后的反汇编视图</figcaption></figure><p>注意，游戏暂停的指令是访问被监视地址的指令<strong>之后</strong>的指令，这意味着写入<hl></hl>HP<hl></hl>值的指令位于<hl></hl>0x2311258。此地址包含指令<hl></hl><code>strh r1, [r7, #10]</code>。你可以看到<hl></hl><code>r7</code><hl></hl>中的地址是<hl></hl>0x21BA528，加上<hl></hl>10（根据<hl></hl><code>strh</code><hl></hl>指令）得到<hl></hl>0x21BA538，即玩家的<hl></hl>HP<hl></hl>地址。<code>r1</code><hl></hl>中包含玩家<hl></hl>HP<hl></hl>刚被设置的新值，这个值也可以在内存查看器中的地址<hl></hl>0x21BA538<hl></hl>看到。</p><p>如果你在<hl></hl>Ghidra<hl></hl>中查看地址<hl></hl>0x2311258<hl></hl>的指令，你会发现该指令位于<hl></hl><code>FUN_02311088</code><hl></hl>内，表明该函数处理被动的<hl></hl>HP<hl></hl>恢复。</p><h3 id="状态保存">状态保存</h3><p>状态保存（Save states）是大多数模拟器的标配功能，可以随时保存和加载游戏状态。除了通常的游戏用途，调试程序时也可以用状态保存做更细致的控制。</p><p>DeSmuME<hl></hl>有十个状态保存槽。要保存或加载状态，可以使用<hl></hl>File &gt; Save State and File &gt; Load State，或它们各自的快捷键。如果你在反汇编器中逐步执行汇编代码，状态保存在调试过程中也很有用，因为你可以多次以相同的游戏状态逐步执行代码。请注意，在逐步执行代码时加载状态可能不会立即刷新游戏内的图形，直到程序继续执行，但这不会影响你逐步执行代码。</p><h3 id="desmume总结">DeSmuME<hl></hl>总结</h3><p>我们已经了解了<hl></hl>DeSmuME<hl></hl>用于检查和调试实时游戏的一些通用工具。该模拟器还有许多本教程不会涉及的更为专业化的工具，例如查看当前加载的调色板、图块（tile）和背景。如果你对这些感兴趣，可以自行探索。</p><h2 id="逆向工程策略">逆向工程策略</h2><p>有了汇编知识、Ghidra<hl></hl>和<hl></hl>DeSmuME，我们就具备了对游戏进行逆向工程的所有工具。本教程的最后部分将讨论一些逆向工程策略，以查找游戏功能在<hl></hl>ROM<hl></hl>和内存中的位置。</p><p>本教程的<hl></hl>DeSmuME<hl></hl>部分讨论了使用<hl></hl><a href="#ram搜索">RAM<hl></hl>搜索</a>和<a href="#监视点">监视点</a>的一些策略，如果你还没有查看，可以回去看看。</p><h3 id="通过汇编代码反向追踪值">通过汇编代码反向追踪值</h3><p>One way to find the location of a specific value is to trace related values backwards through the assembly to find where they came from. This might lead to the value you are looking for.</p><p>找到特定值位置的一种方法是通过汇编代码反向追踪它们的来源。该方法可能会帮你找到要查找的值。</p><p>出于演示目的，我们来找找代码中治疗道具恢复角色<hl></hl>HP<hl></hl>的地方在哪。在游戏中探索迷宫，直到你找到地面上的一个橙橙果（Oran Berry）。你可能不会在当前楼层找到它；如果你探索完当前楼层但没有发现，请寻找楼梯进入下一层继续寻找。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/oran-berry-ds.png" alt="玩家右侧地上的橙橙果"><figcaption aria-hidden="true">玩家右侧地上的橙橙果</figcaption></figure><p>找到橙橙果就走过去把它捡起来。该果实能恢复<hl></hl>100HP（最多恢复到你的<hl></hl>HP<hl></hl>上限），而我们在本演示中的目标是将其更改为只恢复<hl></hl>10HP。为此，我们需要知道<hl></hl>100<hl></hl>这个值在游戏代码中的存储位置。</p><p>你需要将<hl></hl>HP<hl></hl>调低以观察果实恢复了多少<hl></hl>HP，因此请打开内存查看器，将你的<hl></hl>HP（地址<hl></hl>0x21BA538）设置为<hl></hl>01。按<hl></hl>X<hl></hl>键（译注：手柄映射而非键盘按键）打开菜单，进入物品栏，查看你背包中的橙橙果。保存游戏状态，以便你可以返回这个时间点，因为一会得反复吃果实来调试代码。状态保存后，选择该果实，选择食用，最后选择玩家角色，果实将恢复所有玩家的<hl></hl>HP。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/oran-berry-normal-ds.png" alt="正常情况下，橙橙果恢复最多100HP（上限为玩家的HP上限）"><figcaption aria-hidden="true">正常情况下，橙橙果恢复最多<hl></hl>100HP（上限为玩家的<hl></hl>HP<hl></hl>上限）</figcaption></figure><p>现在我们已经看到了橙橙果的正常效果。重新加载状态保存，并使用内存查看器在地址<hl></hl>0x21BA538（玩家的<hl></hl>HP）添加一个写断点。再次食用果实，命中写断点并暂停游戏。进入反汇编器，转到<hl></hl><code>pc</code><hl></hl>指向的地址，向上滚动找到游戏暂停的指令。我们要找的是接下来的<hl></hl><code>strh r0, [r2, #10]</code>，在<hl></hl>0x231529C。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/eat-oran-berry-ds.png" alt="吃掉橙橙果后命中玩家HP写断点"><figcaption aria-hidden="true">吃掉橙橙果后命中玩家<hl></hl>HP<hl></hl>写断点</figcaption></figure><p>刚刚<hl></hl><code>r0</code><hl></hl>被存到玩家的<hl></hl>HP<hl></hl>中了，因此查看反汇编器中的<hl></hl><code>r0</code>，发现值为<hl></hl>0x65（十进制的<hl></hl>101），正好等于橙橙果恢复的<hl></hl>100HP<hl></hl>再加上玩家的<hl></hl>1HP。稍后会有代码将玩家的<hl></hl>HP<hl></hl>限制在其<hl></hl>HP<hl></hl>上限，但未限制的<hl></hl>HP<hl></hl>也可以正常使用。</p><p>之前的两行汇编代码也值得注意。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldrsh</span> <span class="built_in">r0</span>, [<span class="built_in">r2</span>, <span class="number">#10</span>]</span><br><span class="line"><span class="keyword">add</span>   <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br></pre></td></tr></tbody></table></figure><p>游戏加载了玩家的<hl></hl>HP（<code>[r2, #10]</code>，与 <code>strh</code><hl></hl>指令相同），然后又加上了<hl></hl><code>r5</code><hl></hl>的值。<code>r5</code> 的值是<hl></hl>0x64（100），与 橙橙果的治疗量<hl></hl>0x64（100）一致。</p><p>现在我们来看看<hl></hl>0x64<hl></hl>是在哪里赋值给 <code>r5</code> 的。转到<hl></hl>Ghidra<hl></hl>中的地址<hl></hl>0x231529C，找到反汇编器中的相同指令。鼠标中键点击<hl></hl><code>add r0,r0,r5</code><hl></hl>指令中的<hl></hl><code>r5</code><hl></hl>来高亮其用法，然后向上滚动函数。在地址<hl></hl>0x2315288<hl></hl>处有另一个对<hl></hl><code>r5</code><hl></hl>的引用：<code>ldmiaeq sp!, {r3 r4 r5 pc}</code>，但这是函数的早回（early return）（通过从堆栈中弹出到<hl></hl><code>pc</code><hl></hl>来指示），因此可以忽略它。函数的顶部附近有我们要找的指令，地址为<hl></hl>0x2315278<hl></hl>的<hl></hl><code>mov r5, r2</code>。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/trace-oran-berry-ds.png" alt="追踪橙橙果的治疗量到函数的顶部"><figcaption aria-hidden="true">追踪橙橙果的治疗量到函数的顶部</figcaption></figure><p><code>r5</code><hl></hl>中的<hl></hl>0x64<hl></hl>来自<hl></hl><code>r2</code>，但在这里和函数的开始之间没有更多对<hl></hl><code>r2</code><hl></hl>的引用。记得寄存器<hl></hl><code>r0</code>-<code>r3</code><hl></hl>是用于将参数传递给函数的，因此<hl></hl><code>r2</code><hl></hl>是<hl></hl><code>FUN_0231526c</code><hl></hl>的第三个参数，0x64<hl></hl>来自调用<hl></hl><code>FUN_0231526c</code><hl></hl>的代码。下一步是找到该函数的调用者。在<hl></hl><code>FUN_0231526c</code><hl></hl>的底部，找到<hl></hl>0x23152DC<hl></hl>处的<hl></hl><code>ldmia</code><hl></hl>指令，标志着函数的结束。使用<hl></hl>DeSmuME<hl></hl>在<hl></hl>0x23152DC<hl></hl>设置断点，然后继续程序执行以命中断点。注意，在命中断点之前，你会再次命中玩家<hl></hl>HP<hl></hl>的写断点，当时玩家的<hl></hl>HP<hl></hl>被限制在<hl></hl>HP<hl></hl>上限。</p><p>命中函数末尾的断点后，再执行一条指令，查看程序从函数返回后的<hl></hl><code>pc</code><hl></hl>值并向上滚动，找到当前指令。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/oran-berry-end-function-ds.png" alt="函数FUN_0231526c之外"><figcaption aria-hidden="true">函数<hl></hl><code>FUN_0231526c</code><hl></hl>之外</figcaption></figure><p>在当前指令的上方，你可以看到地址<hl></hl>0x2315460<hl></hl>处的<hl></hl><code>bl 0231526c</code>，确认这是调用<hl></hl><code>FUN_0231526c</code><hl></hl>的地方。转到<hl></hl>Ghidra<hl></hl>中的地址<hl></hl>0x2315460。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/oran-berry-outside-function.png" alt="在Ghidra中地址0x2315460调用FUN_0231526c"><figcaption aria-hidden="true">在<hl></hl>Ghidra<hl></hl>中地址<hl></hl>0x2315460<hl></hl>调用<hl></hl><code>FUN_0231526c</code></figcaption></figure><p>我们正在寻找<hl></hl><code>r2</code><hl></hl>被赋值为<hl></hl>0x64<hl></hl>的位置，所以查看函数调用之前的几行。我们可以看到地址<hl></hl>0x231545C<hl></hl>处的<hl></hl><code>mov r2, r5</code><hl></hl>紧接在函数调用之前，意味着<hl></hl>0x64<hl></hl>来自于<hl></hl><code>r5</code>。鼠标中键点击<hl></hl><code>r5</code><hl></hl>并查找写入它的指令。</p><p>在<hl></hl>0x2315378<hl></hl>处的指令是<hl></hl><code>add r5, r5, r0, asr #0x8</code>，它写入了<hl></hl><code>r5</code>。让我们看看在吃橙橙果时是否会到达这条指令。首先，删除现有的断点和观察点，因为我们不再需要它们了。在<hl></hl>0x2315378<hl></hl>处设置断点，重新加载存档状态并吃橙橙果。吃树果时不会触发断点，这意味着这行代码与我们无关。继续查看函数中其他可能给<hl></hl><code>r5</code><hl></hl>赋值的地方。</p><p>下一个相关的指令在函数开始附近，地址为<hl></hl>0x23152F4<hl></hl>处的<hl></hl><code>mov r5,r2</code>。在此处和函数开始之间没有对<hl></hl><code>r2</code><hl></hl>的赋值，所以它再次成为传递给函数的参数。我们需要追踪这个值到调用<hl></hl><code>FUN_023152e4</code><hl></hl>的地方，并从那里跟踪<hl></hl><code>r2</code>，看它是在哪里被赋值为<hl></hl>0x64<hl></hl>的。</p><p>这次，我们使用不同的方法来查找调用函数。删除之前的断点，在<hl></hl>0x23152F4<hl></hl>处设置断点，然后重新加载存档并再次吃橙橙果。这次会触发断点，因此前往反汇编器中的地址<hl></hl>0x23152F4。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/oran-berry-lr.png" alt="地址0x23152F4处的断点"><figcaption aria-hidden="true">地址<hl></hl>0x23152F4<hl></hl>处的断点</figcaption></figure><p>由于这是函数的开头，还没有调用其他函数，因此寄存器<hl></hl><code>lr</code><hl></hl>的值包含了调用函数的返回地址，即地址<hl></hl>0x231C0C8。前往<hl></hl>Ghidra<hl></hl>中的地址<hl></hl>0x231C0C8。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/oran-berry-lr-calling.png" alt="Ghidra中的地址0x231C0C8"><figcaption aria-hidden="true">Ghidra<hl></hl>中的地址<hl></hl>0x231C0C8</figcaption></figure><p>我们可以看到<hl></hl>0x231C0C4<hl></hl>处对<hl></hl><code>FUN_023152e4</code><hl></hl>的函数调用。回到寻找<hl></hl><code>r2</code><hl></hl>被赋值为<hl></hl>0x64<hl></hl>的地方，向上看几行。在<hl></hl>0x231C0A4<hl></hl>和<hl></hl>0x231C0AC<hl></hl>行有对<hl></hl><code>r2</code><hl></hl>的引用。</p><figure class="highlight arm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr</span>   <span class="built_in">r1</span>, [PTR_DAT_0231c730]</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line"><span class="keyword">ldrsh</span> <span class="built_in">r2</span>, [<span class="built_in">r1</span>, <span class="number">#0x0</span>]</span><br></pre></td></tr></tbody></table></figure><p>可以看到一个地址被加载到<hl></hl><code>r1</code>，该地址来自数据值<hl></hl><code>PTR_DAT_0231c730</code>，然后该地址中的值又被加载到<hl></hl><code>r2</code>。在这些指令的右边，Ghidra<hl></hl>的分析显示<hl></hl><code>PTR_DAT_0231c730</code><hl></hl>指向地址<hl></hl>0x22C45EC。</p><p>记住这个地址，回到<hl></hl>DeSmuME<hl></hl>并在内存查看器中转到地址<hl></hl>0x22C45EC。你会在该地址找到<hl></hl>0x64<hl></hl>的值，确认这是橙橙果的<hl></hl>HP<hl></hl>恢复量所在的位置。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/oran-berry-found-ds.png" alt="橙橙果恢复量的位置"><figcaption aria-hidden="true">橙橙果恢复量的位置</figcaption></figure><p>为了测试我们找到的恢复量地址，重新加载存档状态，在内存查看器中将地址<hl></hl>0x22C45EC<hl></hl>的<hl></hl>0x64<hl></hl>更改为<hl></hl>0x0A（0x0A=<hl></hl>十进制的<hl></hl>10），然后再次吃橙橙果看看它恢复了多少。删除之前的断点以避免再次触发，因为他们已经没用了。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/oran-berry-changed-ds.png" alt="更改后的橙橙果恢复量"><figcaption aria-hidden="true">更改后的橙橙果恢复量</figcaption></figure><p>成功了！我们发现橙橙果的恢复量存储在<hl></hl>0x22C45EC。</p><p>橙橙果的恢复量在哪个<hl></hl>overlay<hl></hl>文件里？前文提到，我们加载的<hl></hl>overlay<hl></hl>文件在内存中的地址如下：</p><ul><li>Overlay 10: 0x22BCA80</li><li>Overlay 29: 0x22DC240</li><li>Overlay 31: 0x2382820</li></ul><p>查看这三个地址，overlay 29<hl></hl>和<hl></hl>31<hl></hl>的地址在<hl></hl>0x22BCA80<hl></hl>之后，所以该值位于<hl></hl>overlay<hl></hl>文件<hl></hl>10<hl></hl>中。通过将该值的地址减去<hl></hl>overlay<hl></hl>文件的地址，你可以计算出该值在<hl></hl>overlay<hl></hl>文件中的偏移量（与内存中的偏移量不同）。0x22C45EC - 0x22BCA80 = 0x7B6C。你可以通过在十六进制编辑器中打开<hl></hl><code>overlay_0010.bin</code><hl></hl>并转到字节<hl></hl>0x7B6C<hl></hl>来验证这一点。</p><p>实际上，如果你在<hl></hl><code>overlay_0010.bin</code><hl></hl>中将偏移量<hl></hl>0x7B6C<hl></hl>处的值更改，然后将<hl></hl>ROM<hl></hl>文件重新打包成一个单独的.nds<hl></hl>文件（使用与解包时相同的工具），你将创建一个最小化的<hl></hl>ROM hack，削弱橙橙果的治疗效果。创建<hl></hl>ROM hack<hl></hl>超出了本教程的范围，这里所展示的是如何创建此类<hl></hl>hack<hl></hl>的过程的一部分。</p><h3 id="直接阅读汇编代码">直接阅读汇编代码</h3><p>显然，直接去读汇编代码是了解游戏逻辑的一种方式。</p><p>让我们探索与上一节中相同的功能（玩家通过浆果恢复<hl></hl>HP），并寻找将玩家的<hl></hl>HP<hl></hl>限制在其<hl></hl>HP<hl></hl>上限的代码。返回<hl></hl>Ghidra<hl></hl>中的地址<hl></hl>0x231529C。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/read-assembly-forwards-ds.png" alt="通过浆果恢复玩家HP的汇编代码"><figcaption aria-hidden="true">通过浆果恢复玩家<hl></hl>HP<hl></hl>的汇编代码</figcaption></figure><p>我们看到<hl></hl>0x231529C<hl></hl>处的指令<hl></hl><code>strh r0, [r2, #0x10]</code><hl></hl>将玩家的<hl></hl>HP<hl></hl>设置为恢复量加上玩家的当前<hl></hl>HP。在地址<hl></hl>0x23152BC，你可以看到一个条件<hl></hl><code>ble</code><hl></hl>语句，检查<hl></hl><code>r0</code><hl></hl>是否小于<hl></hl><code>r3</code>。或者，你可以查看反编译代码来找到相同的条件语句。如果条件不满足，则会将另一个值存储到玩家的<hl></hl>HP<hl></hl>中（0x23152CC<hl></hl>处的<hl></hl><code>strh r1, [r2, #0x10]</code>）。</p><blockquote><p>由于使用偏移量访问玩家的<hl></hl>HP，这表明玩家的<hl></hl>HP<hl></hl>位于一个结构体中，可能还包含其他与玩家相关的值。玩家的<hl></hl>HP<hl></hl>在该结构体中的偏移量为<hl></hl>0x10。</p></blockquote><p>虽然我们可以在汇编代码中追踪<hl></hl><code>r0</code><hl></hl>和<hl></hl><code>r3</code><hl></hl>的值，但设置一个断点并查看游戏运行时的值可能更容易。在<hl></hl><code>ble</code><hl></hl>指令<hl></hl>0x23152BC<hl></hl>处添加一个断点，然后重新加载保存的状态并吃掉橙橙果。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/oran-berry-ble.png" alt="命中0x23152BC处的断点"><figcaption aria-hidden="true">命中<hl></hl>0x23152BC<hl></hl>处的断点</figcaption></figure><p><code>r0</code><hl></hl>为<hl></hl>0x65，是橙橙果的恢复量加上玩家<hl></hl>HP<hl></hl>的和（100 + 1 = 101 = 0x65）。<code>r3</code><hl></hl>等于玩家的<hl></hl>HP<hl></hl>上限，截图中为<hl></hl>0x20，即<hl></hl>32，但根据你扮演的不同宝可梦，这个值可能略有不同。这意味着代码检查恢复的<hl></hl>HP<hl></hl>是否大于<hl></hl>HP<hl></hl>上限，并在必要时将玩家的<hl></hl>HP<hl></hl>限制在最大值。如果你继续执行接下来的几条指令，你会看到<hl></hl><code>r1</code><hl></hl>中的值（也等于玩家的<hl></hl>HP<hl></hl>上限）被算作玩家的<hl></hl>HP。</p><p>为了进一步确认，我们可以更改<hl></hl>0x23152CC<hl></hl>处的<hl></hl><code>strh</code><hl></hl>指令，使其不再限制玩家的<hl></hl>HP。在反汇编器中，你可以看到这条指令的十六进制值为<hl></hl><code>E1C211B0</code>。转到内存查看器中的地址<hl></hl>0x23152CC，你会发现那里有值<hl></hl><code>B011C2E1</code>，这是小端格式的<hl></hl><code>E1C211B0</code>。重新加载状态保存，然后将这四个字节更改为<hl></hl><code>00</code>，这将使指令变成一个空操作（即什么也不做的指令）。（译注：准确来说是会变成<hl></hl><code>andeq r0, r0, r0</code>，从指令集设计的角度考虑很有意思。）</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/no-op-instruction-ds.png" alt="将0x23152CC处的指令更改为空操作"><figcaption aria-hidden="true">将<hl></hl>0x23152CC<hl></hl>处的指令更改为空操作</figcaption></figure><p>现在让我们试着吃一颗浆果。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/remove-hp-cap-ds.png" alt="移除恢复HP的上限（某种程度上）"><figcaption aria-hidden="true">移除恢复<hl></hl>HP<hl></hl>的上限（某种程度上）</figcaption></figure><p>游戏现在显示恢复了<hl></hl>100HP，你可能已经注意到面板中当前<hl></hl>HP<hl></hl>一度高于<hl></hl>HP<hl></hl>上限，但随即又被重置回最大值。显然，代码的其他地方还有另一个安全检查，确保玩家的<hl></hl>HP<hl></hl>不会超过最大值。然而，游戏显示了<hl></hl>100HP<hl></hl>的恢复，这证明我们正在查看的代码确实是在检查并限制<hl></hl>HP<hl></hl>恢复。如果你愿意，可以对玩家的<hl></hl>HP<hl></hl>添加另一个写断点，并通过类似的过程找到并禁用其他检查。</p><h3 id="检查已知值附近的值">检查已知值附近的值</h3><p>一旦你在内存中找到了一个值，很可能附近的值也与此相关，例如某个结构体或数组的一部分。我们可以使用内存查看器查看已知值附近的其他<hl></hl>RAM<hl></hl>值，可以用瞪眼法或瞎改法发现更多的值。这种方法没什么特定目标，而是旨在快速发现一系列值，为以后搜索特定值奠定基础。</p><p>本例将使用本教程中找到的玩家<hl></hl>HP<hl></hl>地址。打开内存查看器并转到地址<hl></hl>0x21BA538。既然玩家的<hl></hl>HP<hl></hl>在这里，合理推测其他与玩家角色相关的值也在附近。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/memory-viewer-nearby-ds.png" alt="查看内存中玩家HP附近的值"><figcaption aria-hidden="true">查看内存中玩家<hl></hl>HP<hl></hl>附近的值</figcaption></figure><p>与<hl></hl>HP<hl></hl>直接相关的值是玩家的<hl></hl>HP<hl></hl>上限。查看游戏中的面板以找到你的<hl></hl>HP<hl></hl>上限（在当前<hl></hl>HP<hl></hl>的右侧），然后尝试在内存查看器中找到它。</p><p>你不需要找太远。在当前<hl></hl>HP<hl></hl>的前两个字节处，有一个与你的<hl></hl>HP<hl></hl>上限相匹配的数字，地址为<hl></hl>0x21BA53A。尝试更改此值，你会看到<hl></hl>HP<hl></hl>上限在面板上发生变化，证明<hl></hl>0x21BA53A<hl></hl>就是玩家的<hl></hl>HP<hl></hl>上限。</p><p>另一个靠近的数字是玩家的等级（在面板上标记为<hl></hl>“Lv”），刚开始游戏时为<hl></hl>5。在内存查看器中寻找值<hl></hl>5，一旦找到可能的值，尝试更改它，看看玩家的等级是否在面板上发生变化。正确的地址在下面的提示中。</p><details><summary>剧透：玩家等级的地址</summary><p>0x21BA532</p></details><p>有个类似的方法是在游戏中执行某个动作并观察内存中的值如何变化，包括移动、攻击等。为了演示此方法，在游戏中按住<hl></hl>Y（或<hl></hl>Start）键以进入可以面向不同方向而不移动的模式。转动几次方向，同时观察内存查看器，你会看到地址<hl></hl>0x23BA574<hl></hl>处的值在变化。如果没有其他可见值发生变化，这表明<hl></hl>0x23BA574<hl></hl>是玩家面对的方向（编码为枚举）。</p><p>简单地遍历内存地址，挨个更改它们，并查看是否对游戏中的任何内容产生影响，这也是一种试错法。例如，如果你重复这个过程，最终就会抵达地址<hl></hl>0x21BA5E5。将此值置<hl></hl>1，你会看到玩家角色进入睡眠状态，这表明该值用于记录睡眠状态条件。</p><figure><img loading="lazy" src="/notes/images/nds-reverse-engineering/memory-viewer-asleep-ds.png" alt="发现控制玩家是否入睡的地址"><figcaption aria-hidden="true">发现控制玩家是否入睡的地址</figcaption></figure><p>没有人说得清用这些方法需要投入多少才能找到相关信息，因此你自己决定何时止损换用其他策略。</p><h3 id="策略链">策略链</h3><p>在逆向工程过程中，上述策略通常组合使用。基本思路是从一个已知值开始，找到另一个将你引向所需功能的值。重复此过程，逐步发现更多有助于找到最终目标的值。</p><p>例如，如果你在寻找一个更抽象的概念，比如在游戏中<hl></hl><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=plke4eU_PU8">AI<hl></hl>如何是工作的</a>，你可能会遵循以下步骤：</p><ol type="1"><li>使用<hl></hl>RAM<hl></hl>搜索查找变化，定位内存中的玩家<hl></hl>HP。</li><li>找到一个敌人攻击你，然后在玩家<hl></hl>HP<hl></hl>的地址添加一个写入断点，找出是哪段代码造成了攻击伤害。</li><li>从伤害处理代码开始，反向追踪汇编代码，直到找到游戏决定敌人攻击应该造成伤害的位置。通过使用断点对比伤害攻击和无伤害攻击的代码路径，可能会发现一个用于确定攻击效果的攻击<hl></hl>ID<hl></hl>检查。</li><li>反向追踪汇编代码和<hl></hl>/<hl></hl>或使用观察点，找出代码设置敌人攻击<hl></hl>ID<hl></hl>的位置。这很可能是由敌人<hl></hl>AI<hl></hl>做出的决策，这是进入敌人<hl></hl>AI<hl></hl>代码的切入点。</li><li>正向追踪汇编代码，了解敌人<hl></hl>AI<hl></hl>的工作原理。</li></ol><h3 id="使用现有资源">使用现有资源</h3><p>但凡你正在逆向工程的游戏有点人气，那么很可能已经有其他人已经进行过相关研究。逆向工程文档可能包括已知数据、函数的地址、结构体布局和代码架构等信息，这可以为你节省发现它们的时间，并作为进一步探索游戏信息的起点。</p><p>请注意，游戏的破解和逆向工程资源通常是零散且没人整理的，信息分布在<hl></hl>Google Docs/Sheets、GitHub<hl></hl>仓库、Discord<hl></hl>服务器、Reddit<hl></hl>帖子、论坛、维基等多个平台。可以从<hl></hl><a target="_blank" rel="noopener" href="https://datacrystal.romhacking.net/wiki/Main_Page">Data Crystal</a><hl></hl>开始寻找游戏逆向工程资源，它包含了相当多的游戏的逆向工程文档以及外部资源的链接。Google（或你喜欢的替代搜索引擎）也是个选择，搜索<hl></hl>“&lt;游戏名&gt; hacking”<hl></hl>之类的词可能会带来结果。留意任何活跃的破解和逆向工程社区，比如<hl></hl>Discord<hl></hl>服务器或<hl></hl>subreddit。</p><p>一些逆向工程社区更进一步，维护了一个进行中或已完成的手动<strong>反编译</strong>（decomp）或<strong>反汇编</strong>的项目，使用源代码或结构化的汇编代码构建了一个与实际游戏的<hl></hl>ROM<hl></hl>文件匹配的游戏二进制文件。由于这些项目需要构建匹配的二进制文件，所以它们通常包含大量标记好的游戏信息。例如，《空之探险队》有一个正在进行的反编译项目<a target="_blank" rel="noopener" href="https://github.com/pret/pmd-sky">这里</a>。手动反编译是逆向工程领域中一个高度技术化的子领域，超出了本教程的范围，但如果你正在逆向工程的游戏有这样的项目存在，值得留意。</p><h4 id="空之探险队资源">《空之探险队》资源</h4><p>对于《空之探险队》来说，你可能首先会通过搜索找到<hl></hl>ROM<hl></hl>编辑工具<hl></hl><a target="_blank" rel="noopener" href="https://skytemple.org/">SkyTemple</a>，以及大部分《空之探险队》破解讨论发生的<hl></hl><a target="_blank" rel="noopener" href="https://discord.gg/skytemple">SkyTemple Discord</a>。</p><p>《空之探险队》的破解社区创建了一个集中的文档仓库，称为<hl></hl><a target="_blank" rel="noopener" href="https://github.com/UsernameFodder/pmdsky-debug">pmdsky-debug</a>，用于记录函数、结构体和其他技术数据，并能够将文档导入<hl></hl>Ghidra<hl></hl>和其他逆向工程工具。</p><p>正如前文提到的，《空之探险队》有一个正在进行的<a target="_blank" rel="noopener" href="https://github.com/pret/pmd-sky">反编译</a>项目。</p><p>各种技术文档也可以在<hl></hl><a target="_blank" rel="noopener" href="https://projectpokemon.org/home/docs/mystery-dungeon-nds/pok%C3%A9mon-mystery-dungeon-explorers-r78/">Project Pokémon</a><hl></hl>找到，比如文件格式、压缩算法和解包<hl></hl>ROM<hl></hl>中的所有文件的分解。</p><h2 id="结论">结论</h2><p>到现在为止，你已经搭建了逆向工程环境，学习了汇编基础和一些逆向工程工具，并走过了一些发现游戏内功能的策略。从这里开始，你已经准备好深入你最喜欢的<hl></hl>NDS<hl></hl>游戏的代码，看看能找到什么。请注意，逆向工程过程并不总是简单明了的，它需要足够的创造力和耐心，但这是一个可以通过练习和坚持提高的技能。祝你好运！</p><p>如果你想就本教程与我（译注：原作者）联系，你可以在《宝可梦》神秘迷宫逆向工程服务器如<hl></hl><a target="_blank" rel="noopener" href="https://discord.gg/skytemple">SkyTemple</a><hl></hl>和<hl></hl><a target="_blank" rel="noopener" href="https://discord.gg/d5dubZ3">pret</a><hl></hl>上找到我（Some Body），或者可以在<hl></hl>Reddit<hl></hl>上找到我，用户名是<hl></hl><a target="_blank" rel="noopener" href="https://www.reddit.com/user/AnonymousRandPerson">u/AnonymousRandPerson</a>。</p><p><span class="display-block text-indent-none mt-4 mb-2 fw-600">Fin.</span></p></div></article><aside class="post-widget"><h4>目录<hl></hl></h4><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8ghidra"><span class="post-toc-number">1.</span> <span class="post-toc-text">使用<hl></hl>Ghidra</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">反编译器<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AF%BC%E8%88%AA"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">导航<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%AB%98%E4%BA%AE"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">高亮<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">注释<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A0%87%E7%AD%BE%E5%90%8D%E7%A7%B0"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">标签名称<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ghidra%E6%80%BB%E7%BB%93"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">Ghidra<hl></hl>总结<hl></hl></span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8desmume%E8%BF%9B%E8%A1%8C%E8%B0%83%E8%AF%95"><span class="post-toc-number">2.</span> <span class="post-toc-text">使用<hl></hl>DeSmuME<hl></hl>进行调试<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98%E6%9F%A5%E7%9C%8B%E5%99%A8"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">内存查看器<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ram%E6%90%9C%E7%B4%A2"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">RAM<hl></hl>搜索<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96%E5%99%A8"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">反汇编器<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%AD%E7%82%B9"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">断点<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%91%E8%A7%86%E7%82%B9"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">监视点<hl></hl></span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">状态保存<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#desmume%E6%80%BB%E7%BB%93"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">DeSmuME<hl></hl>总结<hl></hl></span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%AD%96%E7%95%A5"><span class="post-toc-number">3.</span> <span class="post-toc-text">逆向工程策略<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%80%9A%E8%BF%87%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%8F%8D%E5%90%91%E8%BF%BD%E8%B8%AA%E5%80%BC"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">通过汇编代码反向追踪值<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%98%85%E8%AF%BB%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">直接阅读汇编代码<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A3%80%E6%9F%A5%E5%B7%B2%E7%9F%A5%E5%80%BC%E9%99%84%E8%BF%91%E7%9A%84%E5%80%BC"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">检查已知值附近的值<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AD%96%E7%95%A5%E9%93%BE"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">策略链<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%B0%E6%9C%89%E8%B5%84%E6%BA%90"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">使用现有资源<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%A9%BA%E4%B9%8B%E6%8E%A2%E9%99%A9%E9%98%9F%E8%B5%84%E6%BA%90"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">《空之探险队》资源<hl></hl></span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="post-toc-number">4.</span> <span class="post-toc-text">结论<hl></hl></span></a></li></ol></nav></aside></div><footer class="footer-nav"><div class="footer"><div class="back-top" id="back-top" title="Back to top"><i class="icon icon-chevron-bar-up"></i></div><div class="footer-content"><div class="footer-links"><div class="footer-links-column"><p><a title="Google Scholar" target="_blank" rel="noopener" href="https://scholar.google.com/">Google Scholar</a></p><p><a title="Google patents" target="_blank" rel="noopener" href="https://patents.google.com/">Google patents</a></p><p><a title="Bing Academic" target="_blank" rel="noopener" href="https://bing.com/academic/">Bing Academic</a></p></div><div class="footer-links-column"><p><a title="Web of Science" target="_blank" rel="noopener" href="https://www.webofscience.com/">Web of Science</a></p><p><a title="Science Direct" target="_blank" rel="noopener" href="https://www.sciencedirect.com/">Science Direct</a></p><p><a title="中国知网" target="_blank" rel="noopener" href="https://www.cnki.net/"><hl></hl>中国知网<hl></hl></a></p></div><div class="footer-links-column"><p><a title="arXiv" target="_blank" rel="noopener" href="https://arxiv.org/">arXiv</a></p><p><a title="JSTOR" target="_blank" rel="noopener" href="https://www.jstor.org/">JSTOR</a></p><p><a title="PubMed Central" target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/">PubMed Central</a></p></div><div class="footer-links-column"><p><a title="MSI Eureka" target="_blank" rel="noopener" href="https://search.msi-eureka.com/search">MSI Eureka</a></p><p><a title="GitHub" target="_blank" rel="noopener" href="https://github.com/cerallin/">GitHub</a></p><p><a title="KUKE音乐" target="_blank" rel="noopener" href="https://www.kuke.com/">KUKE<hl></hl>音乐</a></p></div></div><div><span id="site_pv">?</span> PV <span id="site_uv">?</span> UV</div>Copyright © 2021<span class="time-divide">-</span>2026 Cerallin. Power by <a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a> and <a href="https://github.com/Cerallin/hexo-theme-yuzu" target="_blank" rel="external nofollow" title="v3.2.7">Theme Yuzu</a>.</div></div></footer><script>window.config={url_root:"/notes/",meta_path:"meta.json"}</script><script src="/notes/js/theme/back-to-top.js"></script><script src="/notes/js/theme/clipboard.js"></script><script src="/notes/js/theme/loading.js"></script><script src="/notes/js/theme/navbar.js"></script><script src="/notes/js/theme/search.js"></script><script src="/notes/js/theme/toc.js"></script><script src="/notes/js/theme/refs-sidebar.js"></script><script>window.onload=function(){for(var e in Theme)Theme[e].register()}</script></div><div class="search-modal" id="search-modal"><div class="card"><div class="card-head"><div class="search-box"><input class="search-input" id="search-input" placeholder="搜索"><div class="search-button" id="search-button"><div class="icon icon-search"></div></div></div><div class="close-button"><div class="icon icon-x"></div></div></div><div class="card-body"><div class="search-count">共<hl></hl><span id="search-count-num">0</span><hl></hl>条搜索结果。</div><div class="search-result" id="search-result"></div></div></div></div></body></html>