<html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="这篇文章介绍了作者开发了一种将OpenCC的C接口封装为Perl模块的方法，以解决小说爬虫中繁体字转换的需求；通过使用XS模块，作者成功创建了一个桥梁，使Perl代码能够调用OpenCC的功能。文章详细讲解了开发过程中的技术要点、目录结构和类型转换原理，并分享了遇到的挑战及解决方案。最终，该项目被应用于实际场景，尽管过程复杂，但作者认为这是一次有趣的编程实践。"><title>使用Perl的XS模块封装C接口 - Cerallin的笔记本 - 瞎折腾～～</title><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="/notes/css/style.css"><link rel="stylesheet" href="/notes/css/helpers.css"><script src="/notes/js/clipboard/clipboard.min.js"></script><script src="/notes/js/bootstrap.js"></script><script>Theme.counter={register:function(){request("//visitor-counter.cerallin.top/count.php/?page="+encodeURI(window.location.href),{method:"GET"}).then(e=>{for(var t in e){var n=document.getElementById(t);n&&(n.innerText=e[t])}}).catch(e=>{console.error("Fetching visit count failed.",e)})}}</script><style>body hl:after {
    content: ' ';
    display: inline;
    font-family: inherit;
    font-size: 0.45em;
}

html code hl,
html pre hl,
html kbd hl,
html samp hl,
html ruby hl,
html .tag-list-item hl {
    display: none;
}

html ol > hl,
html ul > hl {
    display: none;
}</style><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/notes/atom.xml" title="Cerallin的笔记本" type="application/atom+xml"></head><body><div class="loading-wrapper" data-loading="data-loading"><div class="loading"><span></span><span></span><span></span></div></div><div class="page" data-filter="data-filter"><div class="head" data-show="data-show"><header class="head-header"><div class="head-author"><a class="head-author-link" href="/notes/">Cerallin<hl></hl>的笔记本</a></div><div class="head-right"><button class="bar-wrap" id="bar-wrap-toggle" title="菜单按钮"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button><div class="head-item"><a class="search-button head-item-link"><span>搜索</span> <i class="icon icon-search"></i></a></div><div class="head-item"><a class="head-item-link" href="/notes/about">关于</a></div></div></header><div class="menubar-head" id="menubar"><ul class="menubar-ul"><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E9%80%9A%E4%BF%A1%E5%B7%A5%E7%A8%8B/">计算机与通信工程</a></li><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E6%9D%90%E6%96%99%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/">材料科学与工程</a></li><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/">瞎折腾</a></li><li class="menubar-item"><i class="icon icon-chevron-right"></i> <a class="menubar-link" href="/notes/categories/%E6%B5%85%E6%80%9D/">浅思</a></li><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><i class="icon icon-archive"></i> <a class="menubar-link" href="/notes/archives">归档</a></li><li class="menubar-item"><i class="icon icon-tags"></i> <a class="menubar-link" href="/notes/tags">标签</a></li><li class="menubar-item" data-border="data-border"></li><li class="menubar-item"><a class="menubar-link" href="/notes/about"><span>关于</span></a></li></ul><div class="menu-search-box search-button"><div>搜索</div><i class="icon icon-search"></i></div></div></div><div class="main" data-page="post"><article class="post" id="post"><header class="post-head"><h1 class="post-title"><a class="title" href="/notes/2024/08/08/%E4%BD%BF%E7%94%A8Perl%E7%9A%84XS%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85C%E6%8E%A5%E5%8F%A3/">使用<hl></hl>Perl<hl></hl>的<hl></hl>XS<hl></hl>模块封装<hl></hl>C<hl></hl>接口<hl></hl></a></h1></header><div class="post-meta"><div class="post-date"><time class="post-time" itemprop="datePublished" title="2024-08-09 00:00:00" datetime="2024-08-08T16:00:00.000Z">2024-08-09</time></div>|<div class="post-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/OpenCC/" rel="tag">OpenCC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/Perl/" rel="tag">Perl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/notes/tags/Wrapper/" rel="tag">Wrapper</a></li></ul></div><div class="post-visit"><span id="page_pv">?</span><hl></hl>访问</div></div><div class="post-info"><div class="post-word-count">本文共<hl></hl>2,645<hl></hl>字。</div><div class="post-cc">版权声明：署名 | <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC BY 4.0</a></div></div><div class="article-entry" itemprop="articleBody"><blockquote><p>OpenCC<hl></hl>是一款<hl></hl>C++<hl></hl>编写的简繁转换软件，支持词汇级别的转换。虽然<hl></hl>OpenCC<hl></hl>提供了<hl></hl>C、C++、Python、Nodejs<hl></hl>的接口，但是没有提供<hl></hl>Perl<hl></hl>的封装。本文旨在提供一种编程实践：使用<hl></hl>XS<hl></hl>模块封装<hl></hl>C<hl></hl>接口供<hl></hl>Perl<hl></hl>使用。在已经安装了<hl></hl>OpenCC<hl></hl>的计算机上，使用本项目可以方便地在<hl></hl>Perl<hl></hl>程序中调用<hl></hl>OpenCC<hl></hl>的接口。并且，得益于<hl></hl>OpenCC<hl></hl>设计之简单，很少会有内存泄漏的风险。该项目已经实际运用到我的互联网文本自动获取与处理程序之中，至少证明它是有人用的<hl></hl><sup>_</sup></p></blockquote><span id="more"></span><h3 id="引言">引言</h3><p>在<hl></hl>Python<hl></hl>兴起之前，Perl<hl></hl>大概（？）是世界上最流行的脚本语言。虽然<hl></hl>Perl<hl></hl>式微，但是平均薪资很高。以前听信了流言的我抱着试一试的态度学了学。不得不说，Perl<hl></hl>真的很难写。历经千辛万苦的我最终写出一个爬虫程序，直到现在还在运行。于是偶尔维护的我勉强记得<hl></hl>Perl<hl></hl>的语法。</p><p>我的爬虫程序最近遇到了一个需求，某个小说繁体字太多，看着头疼。自然而然地，我想到了<hl></hl>OpenCC<hl></hl>来解决这个问题。作为开源领域遥遥领先的繁简转换项目，OpenCC<hl></hl>提供了许多常用编程语言的接口，包括<hl></hl>C、C++、Nodejs、Python。</p><p>不包括<hl></hl>Perl。</p><p>倒也是意料之中。毕竟不算常用。</p><p>“自己动手丰衣足食”。我之前就有<hl></hl>C<hl></hl>和<hl></hl>C++<hl></hl>互相封装的经验，也看过一点<hl></hl>Python<hl></hl>封装<hl></hl>C<hl></hl>接口的官方文档。虽然当时没有一个契机让我上手操作，所以就搁置了。略微搜索一下，发现果不其然，Perl<hl></hl>也有一套封装<hl></hl>C<hl></hl>接口的终极方案。以往用<hl></hl>cpan<hl></hl>下载包的时候总能看到<hl></hl>gcc<hl></hl>的编译指令，说明先写<hl></hl>C<hl></hl>语言然后再提供给<hl></hl>Perl<hl></hl>的事大家没少干。</p><p>Perl<hl></hl>提供了一个模块用于封装<hl></hl>C<hl></hl>接口，名叫<hl></hl>XS。 XS<hl></hl>这两个字母取自<hl></hl>eXtendable Subroutines，其中<hl></hl>subroutines<hl></hl>就是<hl></hl>Perl<hl></hl>里的函数，或者说子程序。该模块的核心是<hl></hl><code>WriteMakefile</code><hl></hl>函数，允许开发者定义<hl></hl>Makefile<hl></hl>生成策略。与此同时，开发者还需要按照约定组织起特定的文件结构，方便自动生成的<hl></hl>Makefile<hl></hl>识别源文件。通过一系列编辑，再加上一系列指令，代码就可以编译为模块文件<hl></hl>(.pm)<hl></hl>和动态链接库<hl></hl>(.so)。</p><p>本文以<hl></hl>OpenCC<hl></hl>为例向大家简单地介绍一种使用其他语言开发<hl></hl>Perl<hl></hl>模块的通用办法。项目只用一个下午就写完了（包括不少阅读文档和踩坑的时间），扔在<hl></hl>Github<hl></hl>上，哪天有心情的时候会去把<hl></hl>TODOs<hl></hl>做一做。</p><h3 id="opencc-perl">OpenCC-Perl</h3><p><a target="_blank" rel="noopener" href="https://github.com/Cerallin/OpenCC-Perl">OpenCC-Perl</a><hl></hl>并非<hl></hl>OpenCC<hl></hl>的<hl></hl>Perl<hl></hl>实现，而只是对<hl></hl>OpenCC<hl></hl>的一层封装。具体而言，该项目需要用户先在目标计算机上安装好<hl></hl>OpenCC，然后运行本项目才有意义。并且，本项目编译安装好之后，原本的<hl></hl>OpenCC<hl></hl>不能卸载，否则用户在<hl></hl>Perl<hl></hl>里也不能使用<hl></hl>OpenCC<hl></hl>的功能了。</p><h4 id="使用方法">使用方法</h4><p>本项目的使用方法非常简单，new<hl></hl>一个类，然后调用接口，就行了。得益于<hl></hl>OpenCC<hl></hl>接口本来就相当简洁，本项目也没有几行代码，时间都浪费在一遍又一遍的踩坑和<hl></hl>debug<hl></hl>上了……代码示例如下</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> OpenCC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> <span class="variable">$cc</span> = OpenCC-&gt;new(<span class="string">"s2tw.json"</span>);</span><br><span class="line"><span class="variable">$converted</span> = <span class="variable">$cc</span>-&gt;convert(<span class="string">"汉字"</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"<span class="variable">$converted</span>\n"</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="目录结构">目录结构</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── lib</span><br><span class="line">│   └── OpenCC.pm</span><br><span class="line">├── Makefile.PL</span><br><span class="line">├── OpenCC.xs</span><br><span class="line">└── typemap</span><br></pre></td></tr></tbody></table></figure><p>本项目的有效内容如上所示。 <code>Makefile.PL</code><hl></hl>定义了<hl></hl><code>Makefile</code><hl></hl>的生成规则。 <code>lib/OpenCC.pm</code><hl></hl>和<hl></hl><code>OpenCC.xs</code><hl></hl>分别是面向<hl></hl>Perl<hl></hl>和<hl></hl>C<hl></hl>的文件。他们合起来就成为了沟通<hl></hl>Perl<hl></hl>与<hl></hl>C<hl></hl>的桥梁。 <code>typemap</code><hl></hl>定义了<hl></hl>Perl<hl></hl>与<hl></hl>C<hl></hl>的类型转换原则。</p><h3 id="从c到perl的桥梁">从<hl></hl>C<hl></hl>到<hl></hl>Perl<hl></hl>的桥梁</h3><h4 id="opencc的c接口">OpenCC<hl></hl>的<hl></hl>C<hl></hl>接口</h4><p>OpenCC<hl></hl>是<hl></hl>C++<hl></hl>编写的软件，但是也提供了<hl></hl>C<hl></hl>的接口。考虑到兼容性，我们使用<hl></hl>C<hl></hl>接口调用<hl></hl>OpenCC<hl></hl>的库。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载并解压<hl></hl>Release<hl></hl>的源码压缩包，在目录里执行<hl></hl></span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure><p>此时<hl></hl>OpenCC<hl></hl>安装目录为<hl></hl><code>/usr/share/OpenCC</code>。该目录下有四个目录，<code>bin</code>、<code>include</code>、<code>lib</code><hl></hl>和<hl></hl><code>share</code>，分别代表可执行文件目录、C/C++<hl></hl>头文件目录、库文件目录和共享文件目录。所谓共享文件，对于<hl></hl>OpenCC<hl></hl>来说就是繁简转换规则相关的文件。</p><p>查看<hl></hl><code>include/opencc/opencc.h</code>，可以看到接口的核心是<hl></hl><code>opencc_t</code>，从<hl></hl><code>void *</code><hl></hl>指针类型赋予含义而来。众所周知，C/C++<hl></hl>的指针代表数据存放的地址，通常的项目里使用特定的类型区分各种各样的指针，例如<hl></hl><code>float *</code><hl></hl>代表指向浮点数数据的指针，<code>uint32_t *</code><hl></hl>指向非负<hl></hl>32<hl></hl>位整型数的指针。具体的类型有具体的大小，例如<hl></hl><code>uint32_t</code><hl></hl>一定是<hl></hl>32<hl></hl>位的。而<hl></hl><code>void *</code><hl></hl>类型的指针缺失了它所指向的数据的范围。</p><p>作为对外的接口，使用<hl></hl><code>void *</code><hl></hl>暴露句柄有两点好处。一是对外部程序隐藏了自身细节，也就是结构体的定义和数据大小，另外还可以防止外部开发者对不知道长度的指针轻举妄动。</p><p>总而言之，在开发<hl></hl>Perl<hl></hl>模块的时候，我们只需要牢牢记住<hl></hl><code>opencc_t</code><hl></hl>是指针类型就可以了。接下来考，请不要忘掉。</p><h4 id="perl的xs模块">Perl<hl></hl>的<hl></hl>XS<hl></hl>模块</h4><blockquote><p>If you want to write XS, you have to learn it. Learning XS is very difficult.<br>by Steven W. McDougall</p></blockquote><p>第一次看到<hl></hl><a target="_blank" rel="noopener" href="https://metacpan.org/pod/XS::Tutorial::One">XS<hl></hl>文档</a>的这一句的时候，我的心里毫无波澜。因为，ChatGPT<hl></hl>老师已经帮我写好了大半。此时的我对该项目已经有了足够的了解，从始至终完全没有无从下手的感觉。</p><p>赞美<hl></hl>ChatGPT<hl></hl>老师。</p><p>前文写到，<code>lib/OpenCC.pm</code><hl></hl>和<hl></hl><code>OpenCC.xs</code><hl></hl>分别是面向<hl></hl>Perl<hl></hl>和<hl></hl>C<hl></hl>的文件。具体而言，<code>lib/OpenCC.pm</code><hl></hl>像是<hl></hl>C<hl></hl>的头文件，用来暴露给包的使用者，这个文件里需要定义一系列<hl></hl>Perl<hl></hl>侧的函数或者是类，在内部调用<hl></hl><code>OpenCC.xs</code><hl></hl>里约定的<hl></hl>C<hl></hl>接口，或是把符号（也就是函数名）直接暴露出去。 <code>OpenCC.xs</code><hl></hl>使用<hl></hl>XS<hl></hl>特定的一套规则将<hl></hl>C<hl></hl>接口封装起来，实现<hl></hl>Perl<hl></hl>类型和<hl></hl>C<hl></hl>类型之间的相互转换。其语法类似<hl></hl>K&amp;R C（ANSI C<hl></hl>之前的古老的<hl></hl>C<hl></hl>语言语法），一看就懂，不在此赘述。</p><p>接下来我们用一个小例子来进一步说明。例如，<code>opencc_convert_utf8()</code><hl></hl>在原始的<hl></hl>C<hl></hl>接口里是这样定义的：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">opencc_convert_utf8</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">opencc_t</span> opencc,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span>* input,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> length</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p>假如<hl></hl><code>OpenCC.xs</code><hl></hl>里是这样调用的：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SV*</span><br><span class="line"><span class="title function_">opencc_convert_utf8</span><span class="params">(cc, input)</span></span><br><span class="line">    <span class="type">opencc_t</span> cc</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input</span><br><span class="line">  CODE:</span><br><span class="line">    <span class="type">char</span>* result = opencc_convert_utf8(cc, input, <span class="built_in">strlen</span>(input));</span><br><span class="line">    RETVAL = newSVpv(result, <span class="number">0</span>);</span><br><span class="line">  OUTPUT:</span><br><span class="line">    RETVAL</span><br></pre></td></tr></tbody></table></figure><p></p><p>那么，<code>lib/OpenCC.pm</code><hl></hl>里可以这样暴露接口：</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> OpenCC;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...<hl></hl>忽略一些类型声明...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在此处写出要暴露的函数<hl></hl></span></span><br><span class="line"><span class="keyword">our</span> <span class="variable">@EXPORT_OK</span> = <span class="string">qw(opencc_convert_utf8)</span>;</span><br><span class="line"></span><br><span class="line">bootstrap OpenCC; <span class="comment"># 加载 OpenCC.xs</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>; <span class="comment"># Perl<hl></hl>模块文件（.pm）特有的结尾</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>或者，由于<hl></hl><code>opencc_convert_utf8()</code><hl></hl>已经注册成为<hl></hl>Perl<hl></hl>的函数，所以可以进一步地封装：</p><figure class="highlight perl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> OpenCC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> Exporter;</span><br><span class="line"><span class="keyword">require</span> DynaLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">our</span> <span class="variable">@ISA</span> = <span class="string">qw(Exporter DynaLoader)</span>;</span><br><span class="line"></span><br><span class="line">bootstrap OpenCC;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造函数<hl></hl></span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">new</span> </span>{</span><br><span class="line">    <span class="keyword">my</span> ( <span class="variable">$class</span>, <span class="variable">$config</span> ) = <span class="variable">@_</span>;</span><br><span class="line">    <span class="keyword">my</span> <span class="variable">$self</span>-&gt;{_client} = opencc_open(<span class="variable">$config</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">bless</span> <span class="variable">$self</span>, <span class="variable">$class</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">convert</span> </span>{</span><br><span class="line">    <span class="keyword">my</span> ( <span class="variable">$self</span>, <span class="variable">$input</span> ) = <span class="variable">@_</span>;</span><br><span class="line">    <span class="keyword">my</span> <span class="variable">$result</span> = opencc_convert_utf8( <span class="variable">$self</span>-&gt;{_client}, <span class="variable">$input</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p></p><p>在上面的代码里，我封装了一个类，该类的<hl></hl><code>_client</code><hl></hl>属性即为<hl></hl>C<hl></hl>接口的<hl></hl><code>opencc_t</code><hl></hl>句柄。</p><h3 id="after-story">After Story</h3><h4 id="链接装载与库">链接、装载与库</h4><p>如果安装了我的<hl></hl>OpenCC-Perl<hl></hl>库，那么计算机上一定存在以下几个链接库文件：</p><ul><li>libmarisa.a</li><li>libopencc.so</li><li>OpenCC.so</li></ul><p>其中，前两者是安装<hl></hl>OpenCC<hl></hl>的时候编译生成的，位于<hl></hl>OpenCC<hl></hl>目录。最后一个是用于<hl></hl>Perl<hl></hl>运行时动态链接的，位于<hl></hl>perl<hl></hl>模块安装目录。三者呈现一种从下往上的依赖关系。除此之外，<code>OpenCC.so</code><hl></hl>还依赖于<hl></hl><code>libstdc++.so</code>。</p><p>在前文提到的<hl></hl>“一下午”<hl></hl>开发过程中，我主要的时间都用来探索如何编译出用于<hl></hl>Perl<hl></hl>程序链接的静态链接库了。最后不得不放弃了这个想法。这是因为我一直以来都用<hl></hl>PAR Packager<hl></hl>把<hl></hl>Perl<hl></hl>可执行程序打包然后部署到服务器上。所以自然而然地想要静态链接，好方便我打包程序。</p><p>但事实证明我错了。</p><p>使用<hl></hl>PAR Parser<hl></hl>打包的程序根本不是一个完完全全彻彻底底的可执行程序，而是一个把所有文件都打包到一起的类似<hl></hl>tarball<hl></hl>的东西，无论是代码源文件还是动态链接库文件，都在里面。所以我的思路错了。</p><p>不再执着于编译静态库之后，程序很快就写好了。</p><h4 id="回到开始">回到开始</h4><p>一开始我的目的仅仅是在我的爬虫中添加一段代码。这种小小的需求一般是如何实现的呢？</p><p>答案是，调用系统相关函数，新建一个进程，运行<hl></hl>OpenCC<hl></hl>自带的程序即可。前文章节<hl></hl><a href="#opencc的c接口">OpenCC<hl></hl>的<hl></hl>C<hl></hl>接口</a>提到，OpenCC<hl></hl>有一个<hl></hl><code>bin</code><hl></hl>目录。该目录里有名为<hl></hl><code>OpenCC</code><hl></hl>的可执行文件，从<hl></hl>stdin<hl></hl>读取，并将转换结果输出到<hl></hl>stdout，非常适合使用管道传输数据。实际上，许多<hl></hl>filter<hl></hl>都是以管道的思路实现的。</p><p>但是，我没有选择这个方案。虽然开发难度降低了不少，但是这种方案有一个最大的问题：新建进程的开销大以至于运行速度显著变慢。由于我的爬虫采用轮询机制，每隔<hl></hl>10<hl></hl>分钟把订阅的小说挨个检查一遍。非异步的网络请求已经很耗时间了，如果每篇内容的处理速度平均慢上半秒，很可能在极端情况下遇到两个调度相遇的尴尬情况。处理这种情况远比开发<hl></hl>OpenCC<hl></hl>的<hl></hl>Perl<hl></hl>脚本要麻烦，而且我不打算重写成异步的请求，为了不给服务器太大的压力。</p><h3 id="总结">总结</h3><p>总的来说，OpenCC<hl></hl>足够小，非常适合练手，一下午就写完了，这还是因为我执着于静态编译多花了几个小时。如果未来有时间可以加点测试用例，或者实现一套完整的模块，而不需要提前安装<hl></hl>OpenCC。但是<hl></hl>XS<hl></hl>实在是太难写了，过于小众以至于连代码高亮都没有……所以未来不会有机会再用其他语言开发<hl></hl>Perl<hl></hl>模块了，除非加钱。</p><p>加钱！</p><p><span class="display-block text-indent-none mt-4 mb-2 fw-600">Fin.</span></p></div></article><aside class="post-widget"><h4>目录<hl></hl></h4><nav class="post-toc-wrap" id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BC%95%E8%A8%80"><span class="post-toc-number">1.</span> <span class="post-toc-text">引言<hl></hl></span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#opencc-perl"><span class="post-toc-number">2.</span> <span class="post-toc-text">OpenCC-Perl</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">使用方法<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">目录结构<hl></hl></span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%8Ec%E5%88%B0perl%E7%9A%84%E6%A1%A5%E6%A2%81"><span class="post-toc-number">3.</span> <span class="post-toc-text">从<hl></hl>C<hl></hl>到<hl></hl>Perl<hl></hl>的桥梁<hl></hl></span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#opencc%E7%9A%84c%E6%8E%A5%E5%8F%A3"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">OpenCC<hl></hl>的<hl></hl>C<hl></hl>接口<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#perl%E7%9A%84xs%E6%A8%A1%E5%9D%97"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">Perl<hl></hl>的<hl></hl>XS<hl></hl>模块<hl></hl></span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#after-story"><span class="post-toc-number">4.</span> <span class="post-toc-text">After Story</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%93%BE%E6%8E%A5%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">链接、装载与库<hl></hl></span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9B%9E%E5%88%B0%E5%BC%80%E5%A7%8B"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">回到开始<hl></hl></span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-number">5.</span> <span class="post-toc-text">总结<hl></hl></span></a></li></ol></nav></aside></div><footer class="footer-nav"><div class="footer"><div class="back-top" id="back-top" title="Back to top"><i class="icon icon-chevron-bar-up"></i></div><div class="footer-content"><div class="footer-links"><div class="footer-links-column"><p><a title="Google Scholar" target="_blank" rel="noopener" href="https://scholar.google.com/">Google Scholar</a></p><p><a title="Google patents" target="_blank" rel="noopener" href="https://patents.google.com/">Google patents</a></p><p><a title="Bing Academic" target="_blank" rel="noopener" href="https://bing.com/academic/">Bing Academic</a></p></div><div class="footer-links-column"><p><a title="Web of Science" target="_blank" rel="noopener" href="https://www.webofscience.com/">Web of Science</a></p><p><a title="Science Direct" target="_blank" rel="noopener" href="https://www.sciencedirect.com/">Science Direct</a></p><p><a title="中国知网" target="_blank" rel="noopener" href="https://www.cnki.net/"><hl></hl>中国知网<hl></hl></a></p></div><div class="footer-links-column"><p><a title="arXiv" target="_blank" rel="noopener" href="https://arxiv.org/">arXiv</a></p><p><a title="JSTOR" target="_blank" rel="noopener" href="https://www.jstor.org/">JSTOR</a></p><p><a title="PubMed Central" target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/pmc/">PubMed Central</a></p></div><div class="footer-links-column"><p><a title="MSI Eureka" target="_blank" rel="noopener" href="https://search.msi-eureka.com/search">MSI Eureka</a></p><p><a title="GitHub" target="_blank" rel="noopener" href="https://github.com/cerallin/">GitHub</a></p><p><a title="KUKE音乐" target="_blank" rel="noopener" href="https://www.kuke.com/">KUKE<hl></hl>音乐</a></p></div></div><div><span id="site_pv">?</span> PV <span id="site_uv">?</span> UV</div>Copyright © 2021<span class="time-divide">-</span>2026 Cerallin. Power by <a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a> and <a href="https://github.com/Cerallin/hexo-theme-yuzu" target="_blank" rel="external nofollow" title="v3.2.7">Theme Yuzu</a>.</div></div></footer><script>window.config={url_root:"/notes/",meta_path:"meta.json"}</script><script src="/notes/js/theme/back-to-top.js"></script><script src="/notes/js/theme/clipboard.js"></script><script src="/notes/js/theme/loading.js"></script><script src="/notes/js/theme/navbar.js"></script><script src="/notes/js/theme/search.js"></script><script src="/notes/js/theme/toc.js"></script><script src="/notes/js/theme/refs-sidebar.js"></script><script>window.onload=function(){for(var e in Theme)Theme[e].register()}</script></div><div class="search-modal" id="search-modal"><div class="card"><div class="card-head"><div class="search-box"><input class="search-input" id="search-input" placeholder="搜索"><div class="search-button" id="search-button"><div class="icon icon-search"></div></div></div><div class="close-button"><div class="icon icon-x"></div></div></div><div class="card-body"><div class="search-count">共<hl></hl><span id="search-count-num">0</span><hl></hl>条搜索结果。</div><div class="search-result" id="search-result"></div></div></div></div></body></html>